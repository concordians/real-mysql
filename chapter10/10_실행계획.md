# 10. 실행계획

### 10.3.3 table 컬럼

* 실행 계획은 **테이블 기준**으로 표시된다.
* 별도의 테이블을 사용하지 않는 SELECT 쿼리는 table 칼럼에 NULL 표시
* table 칼럼에 <> 로 둘러싸인 이름 -> **임시 테이블**을 의미, 숫자는 단위 select 쿼리의 id값 
  * EX) < derived 2> -> 단위 select 쿼리의 id값이 2인 실행계획으로부터 만들어진 **파생 테이블**



#### 실행 계획 분석

| id   | select_type | table       | ...  |
| ---- | ----------- | ----------- | ---- |
| 1    | PRIMARY     | <derived 2> |      |
| 1    | PRIMARY     | e           |      |
| 2    | DERIVED     | dept_emp    |      |

1. <derived 2> 는 id 2인 단위 select 쿼리 실행계획으로부터 만들어진 파생 테이블, 따라서 id = 2인 라인이 먼저 실행되어야 한다.

2. 세번째 라인 select_type 컬럼 값이 DERIVED, 이 라인은 table 칼럼에 표시된 dept_emp 테이블을 읽어서 파생 테이블을 생성한다는 뜻

3. 세번 째 라인 분석 끝났으면 다시 첫 번째 라인으로 ㄱㄱ
4.  첫 번째, 두 번째 라인은 같은 id값을 가지고 있는 것으로 봐서 2개 테이블이 조인되는 쿼리, <derived 2> 테이블이 e 테이블보다 위에 표시됐기 때문에 <derived 2> 가 드라이빙 테이블, e가 드리븐 테이블

* 실제 쿼리

```mysql
mysql> SELECT *
		FROM 	
			(SELECT de.emp_no FROM dept_emp de GROUP BY de.emp_no) tb,
			employees e
        WHERE e.emp_no=tb.emp_no;
```





### 10.3.4 partitions 칼럼

* 8.0 버전부터 **EXPLAIN** 명령으로 파티션 관련 실행 계획 확인 가능

```mysql
mysql> EXPLAIN
		SELECT *
		FROM employees_2
		WHERE hire_date BETWEEN '1999-11-15' AND '2000-01-15';
```

* 이 쿼리에서 조회하려는 쿼리는 p1996_2000, p2001_2005 파티션에 저장되어 있음을 알 수 있음
* 옵티마이저는 쿼리의 조건을 보고 이 쿼리에서 필요로 하는 데이터가 p1996_2000, p2001_2005 파티션에 있다는 것 알아냄
* 이처럼 파티션이 여러 개인 테이블에서 불필요한 파티션 제외하고 쿼리 수행하기 위해 접급해야 할 것으로 판단되는 테이블만 골라내는 과정을 **파티션 프루닝** 이라고 한다.
* 파티션 프루닝을 위해서 실행 계획을 통해 어느 파티션을 읽는지 확인할 수 있어야 함
* partition 칼럼에 표시

| id   | select_type | table       | partitions             | type | rows  |
| ---- | ----------- | ----------- | ---------------------- | ---- | ----- |
| 1    | SIMPLE      | employees_2 | p1996_2000, p2001_2005 | ALL  | 21743 |

* type 칼럼값이 ALL 인 이유 : employees_2 테이블의 모든 파티션이 아니라 p1996_2000, p2001_2005 파티션에 대해서만 풀 스캔 실행
  * RDBMS에서 파티션은 **물리적으로 개별 테이블처럼** 별도의 저장 공간 가지기 때문에 풀 테이블 스캔이 가능





### 10.3.5 type 칼럼

* 각 테이블의 **접근 방법**을 나타내는 칼럼
* 매뉴얼에서는 type 칼럼을 "조인 타입"으로 소개 -> MySQL 에서는 하**나의 테이블로부터 레코드를 읽는 작업도 조인처럼 처리**하기 때문, SELECT 쿼리의 테이블 개수에 관계없이 실행 계획의 type 칼럼을 "조인 타입"이라 명시

#### 10.3.5.1 system

* 레코드가 1건, 또는 0건 존재하는 테이블 참조하는 형태의 접근방법
* InnoDB에는 X, MyISAM, MEMORY 테이블에서만 사용되는 접근방법

#### 10.3.5.2 const

* 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE조건절을 가짐
* **반드시 1건 반환**
* = 유니크 인덱스 스캔

* 다중칼럼으로 구성된 프라이머리 키, 유니크 인덱스 는 **모든 칼럼**을 **동등 조건**으로 where절에 명시해야만 const 접근 방법 사용

#### 10.3.5.3 eq_ref

* 여러 테이블이 조인되는 쿼리의 실행 계획에서 표시
* 조인에서 처음 읽은 테이블의 칼럼값을 그 다음 읽는 테이블의 **프라이머리 키 or 유니크 키** 칼럼의 검색 조건에 사용하는 접근 방법
* 다중 칼럼으로 구성된 프라이머리 키, 유니크 인덱스라면 인덱스의 **모든 칼럼이 비교 조건에 사용**되어야 eq_ref 접근방법 사용
* 즉, 두 번째 이후에 읽는 테이블에서 **반드시 1건만 존재**한다는 보장 있어야 사용할 수 있다

#### 10.3.5.4 ref

* 인덱스의 종류와 관계없이 **동등 조건**으로 검색할 때 ref 접근방법 사용
* 반환되는 레코드가 반드시 1건이라는 보장 X



 **->세 가지 방법 공통점 : WHERE 조건절에 사용하는 비교 연산자가 동등 비교 연산자(=, <=>)**



#### 10.3.5.5 fulltext

* **전문 검색 인덱스**를 사용해 레코드 읽는 접근 방법
* type 처리 성능 순서는 실제 데이터의 분포, 레코드 건수(통계정보)에 따라 달라질 수 있음 -> 옵티마이저에서 통계 정보를 이용해 비용을 계산하는 이유
* 하지만 전문 검색 인덱스는 **통계 정보가 관리되지 않음**
* 전문 검색 인덱스 사용하려면 **전문 검색 인덱스가 테이블에 정의되어 있어야 함**(아니면 오류 발생)
* 우선 순위가 일반 인덱스 이용하는 range 접근 방법 보다 높으나 range 접근 방법이 더 빨리 처리되는 경우 많음 

-> 전문 검색 쿼리 사용 할 때는 **조건별로 성능 확인해보는 것이 좋음**



#### 10.3.5.6 ref_of_null

* ref 접근 방법과 같은데, null 비교가 추가된 형태



#### 10.3.5.7 unique_subquery

* where 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리 위한 접근 방법
* 서**브쿼리에서 중복되지 않는 유니크한 값만 반환할 때** 사용 가능

#### 10.3.5.8 index_subqeuery

* IN(subquery)에서 서브쿼리 결과의 **중복된 값을 인덱스를 이용해서 제거할 수 있을** 때
* unique_subquery과의 차이점 : unique_subquery는 서브쿼리의 반환 값에 중복이 없음, 별도의 중복 제거 작업 필요 x, index_subqeuery 는 서브쿼리가 중복된 값을 반환할 수 있으나 이를 인덱스를 이용해서 제거 가능

#### 10.3.5.9 range

* **인덱스 레인지 스캔** 형태의 접근방법
* <, >, IS NULL, BETWEEN, IN, LIKE

#### 10.3.5.10 index_merge

* 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후, 그 결과를 병합해서 처리하는 방식
* 특성
  * 여러 인덱스를 읽어야 하므로 일반적인 range 접근 방법보다 효율성 안좋
  * 전문 검색 인덱스 사용하는 쿼리에서는 index_merge 적용 x
  * index_merge 접근방법으로 처리된 결과는 항상 2개 이상의 집합이 됨 -> 두 집합의 교집합, 합집합, 중복 제거 와 같은 부가 작업 필요
* **-> 우선순위를 낮춘 이유**

```mysql
mysql> EXPLAIN
		SELECT * FROM employees
		WHERE emp_no BETWEEN 10001 AND 11000
			OR first_name = 'Smith';
```

* 위 쿼리에서 or로 연결된 두 개 조건 모두 각각 다른 인덱스를 최적으로 사용할 수 있는 조건이다.
* 그래서 옵티마이저는 첫번째 조건은 프라이머리 키를 활용해서 조회하고 두 번째 조건은 ix_firstname 인덱스 이용해 조회한 후 두 결과를 병합하는 형태로 처리



#### 10.3.5.11 index

* **인덱스 풀 스캔**
* 인덱스는 일반적으로 데이터 파일 전체보다는 **크기가 작으므로** 인덱스 풀 스캔 풀 테이블 스캔보다 빠르게 처리, 또한 쿼리의 내용에 따라 **정렬된 인덱스의 장점 이용 가능**하므로 더 효율적
* index 접근 방법을 사용하는 경우 : 1 and 2, 1, and 3 조건을 충족하는 쿼리
  1. range나 const, ref 접근 방법으로 인덱스 사용 못하는 경우
  2. 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우(즉, 데이터 파일 읽지 않아도 되는 경우)
  3. 인덱스 이용해 정렬이나 그루핑 작업이 가능한 경우(즉, 별도의 정렬 작업 피할 수 있는 경우)

```mysql
mysql> EXPLAIN
		SELECT * FROM departments ORDER BY dept_name DESC LIMIT 10;
```

* 위의 쿼리는 where 조건이 없으므로 range, const, ref 접근 방법 사용 불가, 하지만 정렬하려는 칼럼은 인덱스가 있으므로 별도의 정렬 처리 피하기 위해 index 접근 방법 사용
* LIMIT 조건 때문에 인덱스 풀 스캔이지만 인덱스 단순히 역순으로 읽어서 10개만 가져오면 되기 때문에 효율적

#### 10.3.5.12 ALL

* **테이블 풀 스캔**
* InnoDB는 풀 테이블 스캔, 인덱스 풀 스캔과 같은 대량의 디스크 I/O 유발하는 작업 위해 한꺼번에 많은 페이지 읽어 들이는 기능 제공 -> **리드 어헤드**
* 데이터 웨어하우스나 배치 프로그램처럼 대용량의 레코드 처리하는 쿼리에서는 억지로 인덱스를 사용하는 쿼리보다 풀 테이블 스캔이 나은 선택일 수 있음
* 빠른 응답을 사용자에게 보내야 하는 웹 서비스같은 온라인 트랜잭션 처리 환경에서는 적합하지 x



+

* MySQL 서버에서는 인접한 페이지가 연속해서 몇 번 읽히면 백그라운드로 작동하는 읽기 스레드가 최대 64개의 페이지씩 한꺼번에 디스크로부터 읽어 들이기 때문에 한 번에 페이지 하나씩 읽는 작업보다 빠르게 레코드 읽을 수 있음 -> 리드 어헤드
* MySQL 8.0 버전에서는 병렬 쿼리 기능 도입, innodb_parallel_read_threads 시스템 변수 이용해 동시에 몇 개의 스레드 사용할 지 설정 가능 

