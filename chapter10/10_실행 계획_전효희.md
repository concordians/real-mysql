10. 1 통계 정보

- 통계정보 → 실행 계획에 가장 큰 영향
- MySQL 8.0 버전부터 인덱스 되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보 도입
- 10.1.1 테이블 및 인덱스 통계 정보
  - 10.1.1.1 MySQL 서버의 통계정보
    - MySQL 5.5 버전까지는 테이블 통계 정보가 메모리에서만 관리, SHOW INDEX 로만 인덱스 칼럼의 분포도 확인
      → MySQL 서버가 재시작 되면 수집된 통계정보 모두 사라짐
    - 5.6 버전 부터 mysql 데이터베이스의 테이블로 관리할 수 있음 → 기존의 통계정보를 계속 유지 가능
    - STAT_PERSISTENT=1(ON, 디폴트) : 데이터 통계정보를 mysql 데이터베이스에innodb_index_stat 와 innodb_table_stats 테이블에 저장함
    - 통계정보 각 칼럼 : 인덱스가 가진 유니크 값의 개수, 인덱스의 리프노드페이지 개수, 인덱스 트리의 전체페이스 개수 등
    - 자동 통계정보 갱신되는 이벤트 : 테이블 새로 오픈, 데이터 레코드 대량 변경 등
    - 통계 정보 자주 갱신될 경우 (인덱스 스캔대신 풀 테이블 스캔등) MySQL 서버가 잘못된 계획 세울 수 있음
    - STATS_AUTO_RECALC = 1 : 5.5 버전 이전처럼 통계정보 자동 수집  
    - STATS_AUTO_RECALC = 0 : ANALYZE TABLE 명령어 사용시에만 통계정보 수집
    - innodb_stats_transient_sample_pages : 디폴트값 8, 자동으로 통계수집될때 8개 페이지만 임의로 샘플링
    - innodb_stats_persistent_sample_pages : 디폴트값 20, ANALYZE TABLE 명령어 실행되면 임의로 20페이지만 샘플링 하여 분석하고 통계정보 테이블에 저장하고 활용

10.1.2 히스토그램

- 옵티마이저가 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식

-  ANALYZE TABLE ... UPDATE HISTOGRAM

- 히스토그램 종류

  - Singleton(싱글톤 히스토그램) : 칼럼값 개별로 레코드 건수확인하는 히스토그램
  - Equi-Height(높이 균형 히스토그램) : 컬럽값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램

- HISTOGRAM 칼럼이 가진 필드

  - sampling-rate : 히스토그램 정보 수집 위해 스캔한 페이지 비율을 저장한다.
  -  ex) 샘플링 비율 0.35 -> 데이터 페이지의 35% 스캔해서 정보 수집
  - histogram-type: 히스토그램 종류 지정
  - numbet-of buckets-specified : 히스토그램생성 시 설정했던 버킷의 개수를 저장(디폴트 100개)

  
- 10.1.2.2 히스토그램의 용도

   * 히스토그램 도입 이전 인덱스 통계정보만 존재할때는 전체 레코드 건수, 유니크값 개수 정도만 알고 있음 
     → 실제로 데이터는 균등분포가 아니므로 통계정보 부족할 수 있음

   * 히스토그램 사용 시 각 범위(버킷)별 레코드건수, 유니크 값 개수 정보 가지고 더 정확한 예측이 가능

   * 특정 범위의 데이터가 많고 적음에 따라 쿼리 성능에 상당한 차이가 생김

     ```sql
     SELECT * /*+ JOIN_ORDER(e, s)*/
     FROM salaries s
     	INNER JOIN employees e ON e.emp_no=s.emp_no
     				AND e.birth_date BETWEEN '1950-01-01' AND '1950-02-01'
     WHERE s.salary BETWEEN 40000 AND 70000;
     
     
     SELECT * /*+ JOIN_ORDER(s, e)*/
     FROM salaries s
     	INNER JOIN employees e ON e.emp_no=s.emp_no
     				AND e.birth_date BETWEEN '1950-01-01' AND '1950-02-01'
     WHERE s.salary BETWEEN 40000 AND 70000;
     
     // employees 테이블을 먼저 읽은 경우 조인 건수가 salaries 테이블을 먼저 읽은 경우보다 훨씬 적음
     // birth_date, salary 가 인덱스되지 않은 컬럼이라 히스토그램 정보가 없으면 옵티마이저는 데이터 분포 고려 없이 실행계획 수립
     // 히스토그램 없으면 조인의 드라이빙 테이블이 안좋은 것으로 설정 될 수 있음
     ```

   * 히스토그램 정보가 있으면 어느 테이블 먼저 읽어야 조인 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단 가능함

  10.1.2.3 히스토그램과 인덱스

   * 인덱스는 부족한 통계정보 수집하기 위해 사용됨 
     → MySQL 서버에서 플랜 세울때 사용 가능한 인덱스 중 조건에 맞는 레코드 건수 대략 파악해 최종적으로 더 나은 플랜을 선택
   * 인덱스 다이브 : 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저가 실제 인덱스의 B-Tree를 샘플링해서 조회
   * MySQL 8.0 서버 : 인덱스된 칼럼이 검색조건인 경우 그 칼럼의 히스토그램 사용 X, 인덱스 다이브 통해 직접 수집한 정보 활용
   * 실제 검색 조건의 대상 값에 대한 샘플링 실행이므로 항상 히스토그램보다 정확한 결과 기대 가능함
   * 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용됨

10.1.3 코스트 모델

- MySQL 서버가 쿼리 처리하는데 필요한 작업

- 코스트 모델(Cost Model): 전체 쿼리의 비용을 계산하는데 필요한 단위 작업들의 비용

- 버전따른 변화

  | 버전           | 비용 산정 방식                                               |
  | -------------- | ------------------------------------------------------------ |
  | MySQL 5.7 이전 | 작업 비용을 MySQL 서버 소스 코드에 상수화해서 사용           |
  | MySQL 5.7      | 단위 작업비용을 DBMS 관리자가 조정할 수 있게 개선            |
  | MySQL 8.0      | 히스토그램, 인덱스별 메모리 적재 페이지 비율 정보까지 고려하여 비용 산정 |

  

- MySQL 8.0 서버 코스트 모델 설정값 -> mysql DB 에 테이블로 저장

  - server_cost : 인덱스 찾고 /  레코드 비교하고 / 임시 테이블 처리에 대한 비용 관리

  - engine_cost: 레코드를 가진 데이터 페이지 가져오는 데 필요한 비용 관리

  - 각 테이블 공통 컬럼

    | 컬럼명        | 설명                                                         |
    | ------------- | ------------------------------------------------------------ |
    | cost_name     | 코스트 모델의 각 단위 작업                                   |
    | default_value | 각 단위 작업의 비용(기본값, MySQL 서버 소스코드에 설정된 값) |
    | cost_value    | DBMS 관리자가 설정한 값(NULL 이면 default_value 사용)        |
    | last_updated  | 단위 작업 비용이 변경된 시점                                 |
    | comment       | 비용에 대한 추가 설명                                        |

  - engine_cost 테이블에만 추가로 있는 칼럼

    | 컬럼명      | 설명                                                         |
    | ----------- | ------------------------------------------------------------ |
    | engine_name | 비용이 적용된 스토리지 엔진(MEMORY 스토리지 엔진, MyISAM, InnoDB 설정가능) |
    | device_type | 디스크 타입(8.0 에서는 아직 값 활용 X, 값으로 "0"만 설정가능) |

    

  - MySQL 8.0 버전 코스트 모델에서 지원하는 단위 작업

    |             | cost_name                    | default_value | 설명                             |
    | ----------- | ---------------------------- | ------------- | -------------------------------- |
    | engine_cost | io_block_read_cost           | 1.00          | 디스크 데이터 페이지 읽기        |
    | engine_cost | memory_block_read_cost       | 0.25          | 메모리 데이터 페이지 읽기        |
    | server_cost | disk_temptable_create_cost   | 20.00         | 디스크 임시 테이블 생성          |
    | server_cost | disk_temptable_row_cost      | 0.50          | 디스크 임시 테이블의 레코드 읽기 |
    | server_cost | key_compare_cost             | 0.05          | 인덱스 키 비교                   |
    | server_cost | memory_temptable_create_cost | 1.00          | 메모리 임시 테이블 생성          |
    | server_cost | memory_temptable_create_cost | 0.10          | 메모리 임시 테이블의 레코드 읽기 |
    | server_cost | row_evaluate_cost            | 0.10          | 레코드 비교                      |

    

  - row_evaluate_cost : 스토리지 엔진이 반환한 레코드가 쿼리 조건에 일치하는 지 평가하는 단위 작업

  - row_evaluate_cost 값 증가 → 풀테이블 스캔 같은 레코드 처리 비용 높아지고 range scan 같은 적은 수 레코드 처리 비용 낮아짐

  - key_compare_cost : 키 값의 비교 작업에 필요한 비용

  - key_compare_cost 값 증가 → 레코드 정렬과 같이 키 값 비교 처리가 많은 경우 쿼리 비용 높아짐

- 코스트 모델에서 중요한것 : 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행계획들이 저비용으로 바뀌는 지 파악하기

  | 코스트 비용 변화                                             | 대표적인 옵티마이저 예상 결과                                |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | key_compare_cost 비용 높임                                   | 옵티마이저가 가능하면 정렬을 수행하지 않는 plan 선택할 확률 높아짐 |
  | row_evaluate_cost 비용 높임                                  | 옵티마이저가 가능하면 range scan  사용하는 plan 선택할 확률 높아짐 |
  | disk_temptable_create_cost 와 disk_temptable_row_cost 비용 높임 | 옵티마이저가 가능하면 디스크에 임시테이블을 만들지 않는 방향의  plan 선택할 확률 높아짐 |
  | memory_temptable_create_cost 와 memory_temptable_create_cost 비용 높임 | 옵티마이저가 가능하면 메모리에 임시테이블을 만들지 않는 방향의  plan 선택할 확률 높아짐 |
  | io_block_read_cost 비용 높아짐                               | 옵티마이저가 가능하면 InnoDB 버퍼풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 방향의  plan 선택할 확률 높아짐 |
  | memory_block_read_cost 비용 높아짐                           | 옵티마이저가 InnoDB 버퍼풀에 데이터 페이지가 상대적으로 적어도 그 인덱스를 사용하는 방향의  plan 선택할 확률 높아짐 |

  
