# 10장 실행 계획

DBMS가 많은 데이터를 안전하게 저장 및 관리하고, 사용자가 원하는 데이터를 빠르게 조회할 수 있게 하려면 옵티마이저가 최적의 실행 계획을 수립할 수 있어야 한다. 이런 실행 계획이 항상 최적으로 생성되지는 않아서, `EXPLAIN` 명령으로 실행 계획을 확인하고 보완할 수 있어야 한다.

## 10.1 통계 정보

MySQL 5.7 까지는 테이블과 인덱스에 대한 개괄적인 정보만으로 실행 계획을 수립했다. 이는 테이블의 실제 값들의 분포에 대한 정보가 없어서 실행 계획이 정확하지 않은 경우가 많았다. 이를 보완하기 위해 8.0 부터는 `히스토그램`을 도입하여 데이터의 분포도를 수집했다.

### 10.1.1 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 통계 정보는 가장 중요하다. 예를 들어 레코드 건수에 대한 정보가 부정확해서 인덱스 레인지 스캔이 아니라 풀 테이블 스캔을 하는 경우 불필요하게 많은 자원을 사용할 수 있다.

### 10.1.1.1 MySQL 서버의 통계 정보

MySQL 5.6 부터는 InnoDB 엔진을 쓰는 테이블에 대한 통계 정보를 테이블로 관리하여 영구적으로 보관한다. 5.5 까지는 메모리에서 관리되어 휘발성이 강했다. 따라서 서버를 재시작하면 통계 정보가 사라져서 서버를 시작할 때마다 통계 정보를 수집해야 했다.

통계 정보는 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블에서 관리하며, 테이블 생성 시에 `STATS_PERSISTENT` 옵션으로 설정할 수 있다.

```sql
CREATE TABLE table
ENGINE=InnoDB
STATS_PERSISTENT={ DEFAULT | 0 | 1 }
```

- 0: 통계 정보를 5.5 이전 방식대로 관리 ( 테이블에 저장하지 않음 )
- 1: 통계 정보를 테이블에 저장함
- default: 통계 정보 관리 여부를 `innodb_stats_persistent` 시스템 값으로 결정하며,  `STATS_PERSISTENT` 옵션을 별도로 지정하지 않은 것과 동일함.

`innodb_stats_persistent` 는 기본적으로 `ON(1)` 으로 설정되어 있어서, `STATS_PERSISTENT`  옵션을 지정하지 않고 테이블을 생성하면 통계 정보를 테이블에 영구적으로 저장한다.

테이블 생성 후에 `ALTER TABLE` 명령을 실행하면 이 값을 변경할 수 있다.

```sql
ALTER TABLE EMPLOYEES.EMPLOYEES STATS_PERSISTENT=1;
```

MySQL 5.5 까지는 통계 정보가 메모리에 저장되어 서버가 재시작되면 통계 정보가 초기화되어, 서버가 시작되면 모든 테이블의 통계 정보를 다시 수집해야 했다. 또한, 사용자나 관리자가 의도하지 않은 순간에도 발생한 이벤트에 의해 통계 정보가 자동으로 갱신됐다.

- 테이블이 새로 오픈되는 경우
- 테이블의 레코드가 대량으로 변경되는 경우 ( 1/16 정도의 `DELETE`, `INSERT`, `UPDATE` )
- `ANALYZE TABLE` 명령이 수행되는 경우
- `SHOW TABLE STATUS`, `SHOW INDEX FROM` 명령이 수행되는 경우
- InnoDB 모니터가 활성화되는 경우
- `innodb_stats_on_metadata` 값이 ON 인 상태에서 `SHOW TABLE STATUS` 가 수행되는 경우

이렇게 통계 정보가 자주 갱신되면 인덱스 레인지 스캔으로 잘 수행하던 쿼리도 의도치 않게 풀 테이블 스캔으로 실행되어 지연이 발생할 수 있다. 통계 정보의 영구적인 저장으로 의도치 않은 변경을 막을 수 있게 되었다. 또한 `innodb_stats_auto_recalc` 값을 OFF 로 지정하여 자동 갱신을 막을 수 있다. 이 값의 기본값은 ON 이다.

`STATS_AUTO_RECALC` 옵션을 테이블 단위로 지정하여 통계 정보를 자동으로 수집할지 여부도 정할 수 있다.

- 1: MySQL 5.5 이전 방식대로 자동 수집
- 0: `ANALYZE TABLE` 명령 수행시에만 수집
- DEFAULT: 통계 정보 자동 수집 여부를 `innodb_stats_auto_recalc` 시스템 값으로 결정하며, `STATS_AUTO_RECALC` 옵션을 별도로 지정하지 않은 것과 동일.

통계 정보 수집 시에 몇 개의 테이블 블록을 샘플링 할지 다음 두가지 변수로 결정할 수 있다.

- `innodb_stats_transient_sample_pages` : 통계 정보가 자동으로 수집되 때 8개 페이지만 “임의로” 샘플링해서 분석 후 결과를 통계 정보로 활용. 기본값은 8이다.
- `innodb_stats_persistent_sample_pages`: ANALYZE TABLE 명령 수행 시에 20개 페이지만 샘플링해서 분석 후 결과를 영구적인 테이블에 저장하고 활용. 기본값은 20이다.

정확한 통계 정보를 위해서 `innodb_stats_persistent_sample_pages` 값을 높일 수 있다. 그러나 통계 정보 수집 시간도 비례하여 증가한다.

### **10.1.2 히스토그램**

MySQL 5.7 까지의 통계 정보는 인덱스 칼럼의 유니크 값 갯수만 가지고 있어서, 옵티마이저가 최적의 실행 계획을 수립하는 데에는 너무 부족했다. 따라서 옵티마이저는 실제 인덱스의 일부 페이지를 랜덤으로 가져와서 참고하였다. 8.0 부터는 데이터 분포도를 참조할 수 있는 히스토그램을 활용하게 되었다.

### 10.1.2.1 히스토그램 정보 수집 및 삭제

히스토그램 정보는 칼럼 단위로 관리되며, `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 수행해서 수동으로 수집, 관리 한다. 이 정보는 시스템 딕셔너리에 저장되고, 서버가 시작될 때 `information_schema` DB의 `column_statistics` 테이블로 로드한다.

```sql
ANALYZE TABLE EMPLOYEES.EMPLOYEES
UPDATE HISTOGRAM ON GENDER, HIRE_DATE;
```

MySQL 8.0 에서는 다음 2종류의 히스토그램 타입이 지원된다.

- Singleton (싱글톤): 칼럼값 개별로 레코드 건수를 관리. Value-Based 히스토그램 또는 도수 분포라고도 부른다.
- Equi-Height (높이 균형): 칼럼값의 범위를 균등한 개수로 구분해서 관리. Height-Balanced 히스토그램이라고도 부른다.

히스토그램은 버킷 단위로 구분되어 관리되는데, 싱글톤은 칼럼이 가지는 값별로 할당되며 높이 균형에서는 개수가 균등한 칼럼값 범위별로 할당된다. 싱글톤은 [칼럼값, 발생빈도] 로 구성되며 높이 균형은 [범위 시작값, 마지막 값, 발생 빈도율, 유니크한 값의 개수] 로 구성된다. 싱글톤 히스토그램은 주로 코드 값처럼 유니크한 값의 갯수가 상대적으로 적은 경우에 사용된다.

`information_schema` DB의 `column_statistics` 테이블에서 HISTOGRAM 칼럼이 가진 다른 필드들은 다음과 같은 의미를 가진다.

- sampling-rate: 히스토그램 정보를 위해 스캔한 페이지의 비율. 0.35라면 전체 페이지의 35%를 스캔하여 수집한 것.
- histogram-type: 히스토그램의 종류
- number-of-buckets-specified: 히스토그램을 생성할 때 설정했던 버킷의 개수. 기본값으로 100개가 사용되며, 최대 1024개까지 설정할 수 있다.

생성한 히스토그램은 다음 명령으로 삭제할 수 있다. 히스토그램의 삭제는 딕셔너리의 내용만 삭제하므로 쿼리 처리에 영향을 주지 않지만, 실행 계획이 달라질 수 있다.

```sql
ANALYZE TABLE EMPLOYEES.EMPLOYEES
DROP HISTOGRAM ON GENDER, HIRE_DATE;
```

히스토그램을 삭제하지 않고 옵티마이저가 사용하지 않게 하려면 다음과 같이 `optimizer_switch` 시스템 변수를 변경하면 된다.

```sql
SET GLOBAL opimizer_switch='condition_fanout_filter=off';
```

이 경우 `condition_fanout_filter` 옵션에 영향을 받는 다른 최적화 기능이 비활성화될 수 있다.

따라서 특정 커넥션 혹은 특정 쿼리에서만 히스토그램을 비활성화하기 위해 다음과 같이 `SET SESSION` 혹은 `SET VAR` 힌트를 적용할 수 있다.