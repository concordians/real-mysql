옵티마이저가 쿼리를 최적으로 처리될 수 있게 하려면 쿼리의 실행 계획을 수립할 수 있어야 한다. 

MYSQL 서버에서 보여주는 실행 계획을 이해하려면 MYSQL 서버가 데이터를 처리하는 로직을 이해할 필요가 있다. 

MYSQL 서버의 실행 계획에 가장 큰 영향을 미치는 정보인 통계 정보에 대해 살펴보겠다.

# 10.1 통계 정보
MYSQL 5.7까지 실행 계획은 테이블과 인덱스에 대한 개괄적인 정보를 가지고 만들어졌다. 하지만 이는 테이블 컬럼의 값들이 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다.

이러한 문제를 해결하기 위해 MYSQL 8.0부터는 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.

## 1. 테이블 및 인덱스 통계 정보
비용 기반 최적화에서 가장 중요한 것은 통계 정보다! 
통계 정보가 정확하지 않다면 엉뚱한 방향으로 쿼리가 실행될 수 있기 떄문이다.

예를 들어, 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아서 레코드가 10건 미만인 것처럼 통계 정보가 되어 있다면,, 옵티마이저는 인덱스 레인지 스캔이 아니라 풀 테이블 스캔을 선택하여 0.1초에 끝날 쿼리가 1시간이 소요될 수도 있다.

### 1-1) MYSQL 서버의 통계 정보
MYSQL 5.5까지는 통계 정보가 메모리에만 관리되었다. 그래서 MYSQL 서버가 재시작된 경우 통계 정보가 모두 사라지고 모든 테이블의 통계 정보는 다시 수집되어야 했다.

MYSQL 5.6부터는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 개선되었는데, 테이블을 생성할 때 `STATS_PERSISTENT` 옵션을 설정하여 통계 정보를 영구적으로 보관할지 결정할 수 있다.

1. STATS_PERSISTENT = 0
- 통계 정보를 메모리에서만 관리한다.
- MYSQL 5.5과 동일한 방식이다.
2. STATS_PERSISTENT = 1
- 통계 정보를 innodb_index_stats와 innodb_table_stats 테이블에 저장하여 관리한다.
3. STATS_PERSISTENT = DEFAULT
- 테이블에 대한 통계 정보의 영구적 관리 여부를 innodb_stats_persistent 시스템 변수 값으로 결정한다.

`innodb_stats_auto_recalc` 시스템 설정 변수는 통계 정보 자동 갱신 여부를 지정하는 옵션이다.  (기본값: ON)

영구적인 통계 정보를 사용할 때 더 정확한 통계 정보를 수집하고자 한다면 `innodb_stats_persistent_sample_pages` 시스템 변수에 높은 값을 설정해 쿼리 성능을 끌어올릴 수 있다. 하지만 이 값이 너무 높으면 정보 수집 시간이 길어지므로 주의해야 한다.

## 2. 히스토그램
MYSQL 5.7까지의 통계 정보는 단순히 인덱스 컬럼의 유니크한 값의 개수 정도만 가지고 있었다. 하지만 옵티마이저가 최적의 실행 계획을 수립하기에는 정보가 많이 부족했다. 이를 보완하기 위해 MYSQL 8.0부터는 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

### 2-1) 히스토그램 정보 수집 및 삭제
히스토그램 정보는 컬럼 단위로 관리되는데, 이 정보는 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행하여 수동으로 수집 및 관리된다. 

수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고 MYSQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드한다. 

MYSQL 8.0에서는 2종류의 히스토그램 타입이 지원된다.
1. Singleton Histogram(싱글톤 히스토그램)
- 컬럼 값 개별로 레코드 건수를 관리하는 히스토그램이다.
- Value-Based 히스토그램 또는 도수 분포라고 불린다.
- 버킷(Bucket)단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리된다.
2. Equi-Height Histogram(높이 균형 히스토그램)
- 컬럼 값 범위를 균등한 개수로 구분해 관리하는 히스토그램이다.
- Height-Balanced 히스토그램이라고 불린다.
- 컬럼 값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시된다.

### 2-2) 히스토그램의 용도
히스토그램이 도입되기 이전, MYSQL 서버에도 테이블과 인덱스에 대한 통계 정보는 존재했다. 
하지만 테이블의 전체 레코드 건수와 인덱스된 컬럼이 가지는 유니크 값의 개수 정도만 통계 정보로 가지고 있었고, 실제 응용 프로그램의 데이터는 항상 균등한 분포를 가지지 않는 것을 기존 MYSQL 서버는 고려하지 못했다.

히스토그램은 각 범위(버킷) 별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다. 이러한 이점으로 MYSQL 8.0부터 히스토그램이 도입되었다.

또한 히스토그램 정보는 조인 쿼리에도 성능에 상당한 영향을 미칠 수 있다. 조인 시 드라이빙 테이블을 선택할 때 옵티마이저가 통계 정보를 활용해 결정하기 때문이다.

### 2-3) 히스토그램과 인덱스
히스토그램과 인덱스는 완전히 다른 객체이기 때문에 비교 대상은 아니지만, MYSQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 어느 정도 공통점을 가진다고 볼 수 있다.

MYSQL 서버는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다. 
이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴보는데 이를 `인덱스 다이브(Index Dive)`라고 표현한다.

## 3. 코스트 모델
MYSQL 서버가 쿼리를 처리하려면 아래의 작업을 필요로 한다.
- 디스크로부터 데이터 페이지 읽기
- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

MYSQL 서버는 쿼리에 대해 이러한 작업이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 실행 계획을 만든다. 이렇게 전체 쿼리 비용을 계산하는데 필요한 단위 작업들의 비용을 코스트 모델이라고 한다.

MYSQL 5.7 이전까지는 이런 작업 비용을 MYSQL 서버 소스 코드에 상수화해서 사용했다. 
하지만 사용하는 하드웨어에 따라 비용은 달라질 수 있기 때문에, 고정된 비용을 일괄적으로 적용하는 것은 실행 계획 수립을 최적화하기 어려웠다.

이러한 단점을 보완하기 위해 MYSQL 5.7부터 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있게 개선되었지만, 인덱스되지 않은 컬럼의 데이터 분포(히스토그램)나 메모리에 저장되어 있는 페이지의 비율 등 비용 계산과 연관된 부분의 정보는 여전히 부족한 상태였다. 이러한 정보는 MYSQL 8.0이 되어서야 비로소 히스토그램과 인덱스 별 메모리의 페이지 비율이 관리됨으로써 옵티마이저의 실행 계획 수립에 사용되기 시작했다.

MYSQL 8.0 버전의 코스트 모델에서 지원하는 단위 작업은 다음과 같이 8개이다.
1. row_evaluate_cost
- 스토리지 엔진이 반환한 레코드가 쿼리의 조건에 일치하는지 평가하는 단위 작업을 의미한다.
- 값이 증가할수록 풀 테이블 스캔과 같이 많은 레코드를 처리하는 쿼리의 비용이 높아지고, 레인지 스캔과 같이 상대적으로 적은 수의 레코드를 처리하는 쿼리의 비용은 낮아진다.
- 해당 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아지고, 옵티마이저는 가능하면 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다.
2. key_compare_cost
- 키 값의 비교 작업에 필요한 비용을 의미한다.
- 값이 증가할수록 레코드 정렬과 같이 키 값 비교 처리가 많은 경우 쿼리의 비용이 높아진다.
- 비용을 높이면, 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
3. disk_temptable_create_cost / 4. disk_temptable_row_cost
- 해당 비용을 높이면 옵티마이저는 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
5. memory_temptable_create_cost / 6. memory_temptable_row_cost
- 해당 비용을 높이면 옵티마이저는 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
7. io_block_read_cost
- 해당 비용이 높아지면 옵티마이저는 가능하면 InnoDB 버퍼 풀에 데이터 페이지가 많이 적재되어 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다.
8. memory_block_read_cost
- 해당 비용이 높아지면 MYSQL 서버는 InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 시용할 가능성이 높아진다.