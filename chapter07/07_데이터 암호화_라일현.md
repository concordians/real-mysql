# 데이터 암호화

## 7.1 MySQL 서버의 데이터 암호화
- 서버의 암호화 기능은 **서버와 디스크 사이의 데이터 읽고 쓰기 지점**에서 암호화 복호화 수행 (I/O 레이어)
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/uK9ArrOke1.png "MySQL 서버의 디스크 입출력")
- TDE(Transparent Data Encryption/Data at Rest Encryption)
	MySQL 서버에서 사용자의 쿼리를 처리할 때 테이블의 데이터가 암호화돼 있는지 여부를 식별할 필요가 없고, 암호화 기능이 활성화되어 있어도 MySQL 내부와 사용자 입장에서 아무런 차이가 없는 암호화 방식 (Data at Rest : 디스크에 저장된 단계에서만 암호화된다는 의미)

### 7.1.1 2단계 키 관리
- MySQL 서버의 TDE에서 암호화 키는 키링 플러그인에 의해 관리됨
- 다양한 플러그인이 제공되지만 마스터키를 관리하는 방법만 다르고 내부적으로 작동하는 방식은 같음
- 키링 플러그인
	1. keyring_file File-Based 플러그인 (커뮤니티 에디션은 해당 플러그인만 가능)
	2. keyring_encrypted_file Keyring 플러그인
	3. keyring_okv KMIP 플러그인
	4. keyring_aws Amaznon Web Services Keyring 플러그인
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/QfDExDqpp6.png "2단계 암호화 아키텍처")
- 외부 키 관리 솔루션 또는 디스크 파일에서 마스터 키를 가져오고 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키를 발급
- 서버는 마스터 키를 이용해 테이블스페이스키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장 (이렇게 생성된 테이블스페이스 키는 테이블이 삭제되지 않는 이상 변경X - 테이블스페이스 키는 절대 서버 외부로 노출되지 않으므로 키를 주기적으로 변경하지 않아도 보안 취약점이 아님)
- 마스터 키는 외부의 파일을 이용하기 때문에 노출될 가능성이 있으므로 주기적으로 변경해줘야 한다
	ALTER INSTANCE ROTATE INNODB MASTER KEY;
- 마스터 키를 변경하면 MySQL 서버는 기존의 마스터 키를 이용해 각 테이블 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화
- 마스터 키가 변경되는 동안 서버의 테이블스페이스 키 자체와 데이터 파일의 데이터는 변경되지 않음
- 2단계 암호화 방식 사용 이유 : 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위함 (테이블스페이스 키가 변경된다면 서버는 데이터 파일의 모든 데이터를 다시 복호화했다 다시 암호화 해야 함)
- MySQL 서버의 TDE 지원 암호화 알고리즘은 AES 256비트 (이외의 알고리즘 지원X)
	테이블스페이스 키 : AES-256 ECB 알고리즘
	실제 데이터 파일 : AES-256 CBC 알고리즘

### 7.1.2 암호화와 성능
- MySQL 서버의 암호화는 TDE 방식이므로 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB의 버퍼 풀에 적재
	따라서 데이터 페이지가 한 번 메모리에 적재되면 암호화하지 않은 테이블과 동일한 성능
	InnoDB 버퍼 풀에 없는 데이터 페이지를 읽는 경우 복호화 과정을 거치므로 복호화 시간동안 쿼리 지연이 생김
	사용자 쿼리 처리는 스레드가 아닌 MySQL 서버의 백그라운드 스레드가 수행하기 때문에 실제 사용자 쿼리가 지연되는 것은 아님
- AES 암호화 알고리즘은 평문의 길이가 짧으면 암호화 키의 크기에 따라 결과의 용량이 더 커질 수 있지만 데이터 이미 데이터 페이지는 암호화 키보다 훨씬 크므로 암호화 결과가 평문의 결과와 동일한 크기의 암호문을 반환한다
- TDE를 적용해도 데이터 파일 크기 == 암호화되지 않은 테이블
- 같은 테이블에 암호화와 압축이 동시에 적용되면 서버는 압축을 먼저 암호화 나중
	암호화된 결과문이 랜덤한 바이트 배열을 가지는데 이는 압축률을 떨어뜨림
	암호ㅓ화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만 압축된 데이터 페이지는 압축 또는 압축 해제의 모든 상태로 InnoDB 버퍼풀에 존재(버퍼 풀에 존재하는 데이터 페이지에 대해서도 암호화 작업 수행 필요)
	
### 7.1.3 암호화와 복제
- MySQL 서버에서 모든 노드는 각자의 마스터 키를 할당해야 함
- 소스 서버와 레플리카 서버는 다른 마스터키를 갖도록 설정해야 함
- 소스 서버와 레플리카 서버는 각자의 마스터 키와 테이블스페이스 키를 가짐 > 복제 멤버들의 데이터 파일은 암호화되기 전의 값이 동일하더라도 실제 암호화된 데이터가 저장된 데이터 파일의 내용은 달라짐
- 복제 소스 서버의 마스터 키를 변경할 때 ALTER INSTANCE ROTATE INNODB MASTER KEY 명령 실행

## 7.2 keyring_file 플러그인 설치
- 마스터 키(테이블스페이스 키를 암호화하기 위한 키)를 디스크의 파일로 관리 (평문으로 디스크에 저장)
- TDE 플러그인의 경우 MySQL 서버가 시작되는 단계에서 가장 빨리 초기화되어야 한다 (이유 찾아보기)
	MySQL 서버의 설정 파일(my.cnf)에서 early-plugin-load 시스템 변수에 keyring_file 플러그인을 위한 라이브러리("keyring_file.so")를 명시하면 됨
- 하나의 서버에 MySQL 서버가 2개 이상 실행 중이면 각 MySQL 서버가 서로 다른 키링 파일을 설정하도록 해야 함
```
early-plugin-load = keyring_file.so
keyring_file_data = /very/secure/directory/tde_master.key
// keyring 초기화 여부 확인 명령
mysql> SHOW PLUGINS;
```

## 7.3 테이블 암호화

### 7.3.1 테이블 생성
```
// TDE를 이용하는 테이블 생성
mysql> CREATE TABLE tab_encrypted (
	id INT,
	data VARCHAR(100),
	PRIMARY KEY(id),
) ENCRYPTION='Y';
mysql> INSERT INTO tab_encrypted VALUES(1, 'test_data');
mysql> SELECT * FROM tab_encrypted;

// 암호화된 테이블만 검색
mysql> SELECT table_schema, table_name, create_options
	FROM information_schema.tables
	WHERE table_name='tab_encrypeted';
```
- 서버 모든 테이블에 암호화 적용하고자 한다면 default_table_encryption=ON 설정

### 7.3.2 응용 프로그램 암호화와의 비교
- 응용 프로그램에서 암호화된 칼럼은 인덱스를 생성해도 기능을 100% 활용할 수 없음 (범위 검색, 정렬 등)
- 응용 프로그램의 암호화보다 MySQL 서버의 암호화 기능을 선택하는 것을 권장, 하지만 서비스 요건과 성능에 따라 다르게 선택해야 함 (혼합 사용도 가능)
- MySQL 서버의 TDE 기능으로 암호화하면 실행 중인 MySQL 서버에 로그인만 할 수 있다면 모든 데이터를 평문으로 확인 가능
- 응용 프로그램 암호화는 MySQL 서버에 로그인해도 평문 확인 불가능

### 7.3.3 테이블스페이스 이동
- 특정 테이블의 데이터 파일만 백업했다 복구하는 경우엔 레코드를 덤프했다 복구하는 방식보다 테이블스페이스 이동 기능이 효율적임
- TDE가 적용된 암호화 테이블의 경우 원본 서버와 목적지 서버의 암호화 키(마스터 키)가 다르기 때문에 FLUSH TABLE 명령으로 테이블 스페이스를 익스포트할 수 있음
```
mysql> FLUSH TABLES source_table FOR EXPORY;
// 위 명령 실행 후
// source_table의 저장되지 않은 변경 사항을 모두 디스크로 기록하고 source_table에 접근할 수 없도록 잠금
// source_table의 구조를 source_table.cfg 파일로 기록 (암호화된 테이블이면 임시로 사용할 마스터키 발급 후 source_table.cfp라는 파일로 기록 > 없어지면 복구 불가능)
// source_table.idb 파일과 source_table.cfg 파일을 목적지 서버로 복사
// 복사가 모두 완료되면 UNLOCK TABLES 명령을 실행해 source_table을 사용할 수 있게 함
```

## 7.4 언두 로그 및 리두 로그 암호화
- 테이블의 암호화를 적용해도 디스크로 저장되는 데이터만 암호화되고 메모리에 존재하는 데이터는 복호화된 평문이며, 이 평문 데이터가 데이터 파일 이외의 디스크 파일로 기록되는 경우 여전히 평문으로 저장됨
	따라서 테이블 암호화를 적용해도 리두 로그나 언두 로그 복제를 위한 바이너리 로그에는 평문으로 저장됨
- 8.0.16 버전 부터는 시스템 변수를 이용해 InnoDB 스토리지 엔진의 리두 로그와 언두 로그를 암호화된 상태로 저장할 수 있도록 개선 (innodb_undo_log_encrypt, innodb_redo_log_encrypt)
- 실행중인 MySQL 서버에서 암호화를 활성화한다해도 언두 로그, 리두 로그는 해당 시점에 한 번에 암호화해서 저장하는게 불가능 > 활성화되면 그 때부터 암호화해서 저장 > 비활성화되면 그 시점부터 평문으로 저장
- 테이블스페이스 키는 언두 로그, 리두 로그를 암호화하고 테이블스페이스 키는 마스터 키로 암호화됨
- 리두 로그와 언두 로그 데이터 암호화에 쓰이는 키는 테이블스페이스 키라고 했지만 실제로 암호화에 사용된 키는 프라이빗 키를 말함 (리두 로그 언두 로그를 위한 각각의 프라이빗 키가 발급되고 해당 프라이빗 키가 마스터 키로 암호화되어 리두 로그 파일과 언두 로그 파일의 헤더에 저장됨)

```
// 리두 로그 암호화 확인 방법
mysql> SHOW GLOBAL VARIABLES LIKE 'innodb_redo_log_encrypt';

mysql> INSERT INTO enc VALUES (2, 'Real-MySQL');
mysql> SET GLOBAL innodb_redo_log_encrypt=ON;
mysql> INSERT INTO enc VALUES (2, 'Real-MongoDB');
// 이후 INSERT된 문자열들이 InnoDB의 리두 로그에 보이는지 확인 > grep으로 확인해보면 암호화전인 Real-MySQL만 검색 가능
```

## 7.5 바이너리 로그 암호화
- 테이블 암호화가 적용돼도 바이너리 로그와 릴레이 로그 파일 또한 리두 로그나 언두 로그처럼 평문을 저장
- 바이너리 로그는 암호화하는 상황에 따라 중요도가 높을 수 있음
- 바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당
- MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터를 암호화하진 않음
- 복제 멤버 간의 네트워크 구간에서도 바이너리 로그를 암호화하고자 한다면 MySQL 복제를 위한 계정이 SSL을 사용하도록 설정하면 됨

### 7.5.1 바이너리 로그 암호화 키 관리
- 2단계 암호화 키 관리 방식
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/NGzXQhemg6.jpg "바이너리 로그 파일의 암호화 방식")
- 바이너리 로그와 릴레이 로그 암호화 : 파일 키 / 파일 키 암호화 : 바이너리 로그 암호화 키
- 파일 키는 바이너리 로그와 릴레이 로그 파일 단위로 자동으로 생성되어 해당 로그 파일의 데이터 암호화에만 사용됨

### 7.5.1 바이너리 로그 암호화 키 변경
```
// 바이너리 로그 암호화 키 변경
mysql> ALTER INSTANCE ROTATE BINLOG MASTER KEY;

// 바이너리 로그 파일 암호화 여부 확인
mysql> SHOW BINARY LOGS;
```
- 바이너리 로그 암호화키 변경 과정
	1. 증가된 시퀀스 번호와 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
	2. 바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션)
	3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고, 파일 키는 바이너리 로그 파일 키(마스터 키)로 암호화해서 각 로그 파일에 저장
	4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장(암호화되지 않은 로그 파일은 무시) -> 시간이 조금 소요될 수 있음
	5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거

### 7.5.3 mysqlbinlog 도구 활용
- 바이너리 로그 암호화 키는 그 바이너리 로그나 릴레이 로그 파일을 생성한 MySQL 서버만 가지고 있으므로 MySQL 서버와 관계없이 mysqlbinlog 도구만으로는 복호화 불가 -> 복호화를 위해 무조건 MySQL 서버에 접속해야서 활용
	
