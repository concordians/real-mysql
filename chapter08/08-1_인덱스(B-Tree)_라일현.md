# 8장 인덱스

## 8.1 디스크 읽기 방식
- DB 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 많음 (특히 랜덤 I/O)

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
- CPU 메모리, SSD - 전자식 장치 / 하드 디스크 드라이브 - 기계식 장치
- SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)를 제거하고 그 대신 플래시 메모리 장착(전원이 공급되지 않아도 데이터가 삭제되지 않음) - 메모리(D-RAM)보단 느리지만 기계식 하드 디스크 드라이브보다 빠름

### 8.1.2 랜덤 I/O와 순차 I/O
- 순차 I/O
	**디스크 헤더를 움직이지 않고** 한 번에 많은 데이터를 읽음 (SSD와 하드 디스크 드라이브의 성능차이가 크지 않음)
- 랜덤 I/O
	하드 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 **데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음** 데이터를 읽는 것 -> 작업부하↑
	읽어야하는 데이터가 물리적으로 불연속적으로 있기 때문에 디스크 헤더를 이동 시킨 다음 데이터를 읽는 것 (SSD의 성능이 더 좋음)
	원판이 없는 SSD도 랜덤 I/O가 스루풋(?)이 떨어짐
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/rB19kjboMr.png "순차 I/O(왼쪽)와 랜덤 I/O(오른쪽) 비교")
	순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 디스크 헤드를 1번 움직임 / 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 디스크 헤드를 3번 움직임
- 디스크 성능 : 디스크 헤더 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하는가에 의해 결정됨
- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며 풀 테이블 스캔을 순차 I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다. -> OLTP(ON-LINE TRANSACTION PROCESSING)성격의 웹보다 DW, 통계 작업에서 주로 사용됨

## 8.2 인덱스란?
- SortedList - DBMS의 인덱스와 같은 자료 구조 (저장된 값을 항상 **정렬된 상태**로 유지)
	장점 : 데이터가 정렬되어 있어 조회가 빠름 (SELECT)
	단점 : 항상 값을 정렬해야 하므로 저장이 느림 (INSERT, UPDATE, DELETE)
- ArrayList - 데이터 파일과 같은 자료 구조 (저장된 값을 **순서대로** 유지)
- 인덱스의 임의 분류
	- 역할
		프라이머리 키 : 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스(식별자), NULL/중복 X
		세컨더리 인덱스 : 프라이머리 키를 제외한 나머지 인덱스
	- 데이터 저장 방식(알고리즘)
		B-Tree 인덱스 : 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱
		Hash 인덱스 : 칼럼의 값으로 해시값을 계산해서 인덱싱, 매우 빠른 검색 지원, 메모리 기반의 DB에서 많이 사용
	- 데이터 중복 허용 여부
		유니크 인덱스 : 같은 값이 1개 존재
		유니크하지 않은 인덱스 : 중복 데이터 존재 가능
	- 인덱스 기능
		전문 검색용 인덱스
		공간 검색용 인덱스

## 8.3 B-TREE 인덱스
- B-Tree(Balanced-Tree)는 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지
- 전문 검색과 같은 특수한 요건이 아닌 경우 대부분 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘

### 8.3.1 구조 및 특성
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/nuoBX9Bk4y.png "B-Tree 인덱스의 구조")
- 루트 노드(최상위) -> 브랜치 노드(중간) -> 리프 노드(최하위)
- 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있음 (DB에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리됨)
- 인덱스 키 값은 모두 정렬되어 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있음 (데이터 파일의 레코드는 INSERT 순서대로 저장되는 것이 아님 / 레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계됨)
- InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장됨 (오라클의 IOT나 MS-SQL의 클러스터 테이블과 같은 구조)
	클러스터링 : 비슷한 값을 최대한 모아서 저장하는 방식
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 함 -> 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가짐
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/LTIjQQGzsS.png "B-Tree의 리프 노드와 테이블 데이터 레코드(MyISAM)")
	레코드 주소 : MyISAM 테이블의 생성 옵션에 따라 레코드가 테이블에 INSERT된 순번 혹은 데이터 파일 내의 위치
	MyISAM 테이블은 세컨더리 인덱스가 **물리적인 주소**를 가짐
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/dJVRzKkb6i.png "B-Tree의 리프 노드와 테이블 데이터 레코드(InnoDB)")
	InnoDB 테이블은 프라이머리 키를 주소처럼 사용하므로 **논리적인 주소**를 가진다고 볼 수 있음
	그래서 MyISAM 처럼 데이터 파일을 바로 찾아가지 못함 (인덱스 안의 PK로 프라이머리 키 인덱스 검색 > 프라이머리 키 인덱스 리프 페이지에 저장된 레코드 조회)
	InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 함

### 8.3.2 B-TREE 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 키 추가
- B-Tree에 저장될 때 저장될 키 값을 이용해 B-Tree상의 적절한 위치 검색
- 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장
- 리프 노드에 더 저장할 수 없을 때는 리프 노드가 분리되어야 함 -> 상위 브랜치 노드까지 처리의 범위가 넓어짐
- 이런 작업때문에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 듦
- MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에선 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경
- InnoDB 스토리지 엔진은 필요 시 인덱스 키 추가 작업을 지연시켜 나중에 처리 가능 (프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요해서 즉시 B-Tree에 추가, 삭제 처리)

#### 8.3.2.2 인덱스 키 삭제
- 삭제할 값의 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 인덱스 키 삭제 작업 완료
- 삭제 마킹된 인덱스 키 공간은 방치, 재활용 가능
- 삭제 마킹도 디스크 쓰기가 필요한 디스크 I/O 작업으로 필요 시 버퍼링되어 지연 처리될 수 있음

#### 8.3.2.3 인덱스 키 변경
- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것이 불가능
- 먼저 키 값을 삭제 후 다시 새로운 키 값을 추가하는 형태로 처리
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리될 수 있음

#### 8.3.2.4 인덱스 키 검색
- 인덱스를 구축하는 이유는 **빠른 검색**을 위함
- 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하며 비교 작업을 수행 -> 트리 탐색
- 인덱스 트리 탐색은 SELECT에서만 사용하는 것이 아닌 UPDATE, DELETE를 처리하기 위해 해당 레코드를 먼저 검색해야 할 경우에도 사용
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우 사용 가능
- 부등호 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 불가능
- 인덱스의 키 값이 변형되면 B-Tree의 빠른 검색 기능 사용 불가능 - 이미 변형된 값은 B-Tree에 존재하지 않음 (함수, 연산을 수행한 결과로 정렬 및 검색 불가능)
- InnoDB 테이블에서 레코드 잠금, 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는데 UPDATE, DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠글 수 있다

### 8.3.3 B-TREE 인덱스 사용에 영향을 미치는 요소
- 인덱스를 구성하는 칼럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수 -> 검색이나 변경 작업의 성능이 영향 받음

#### 8.3.3.1 인덱스 키 값의 크기
- 페이지(블록) : InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위, 디스크의 모든 읽기 쓰기 작업의 최소 작업 단위, 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
- 인덱스도 페이지 단위로 관리되며, 루트/브랜치/리프 노드를 구분한 기준이 페이지 단위
- MySQL의 B-Tree는 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드를 가짐
- InnoDB 스토리지 엔진의 페이지 크기 기본값은 16KB

![](https://i.esdrop.com/d/f/5BqG1Oh0zF/oNsTlF4pMW.png "인덱스 페이지의 구성")
- 인덱스 키가 16바이트라고 가정함 (자식 노드 주소는 여러 가지 복합적인 정보가 담긴 영역 / 평균적으로 12바이트)
- 하나의 인덱스 페이지(16KB)에 16*1024/(16+12) = 585 개 자식 노드를 가질 수 있음 -> 인덱스 키 값이 커지면 가질 수 있는 자식 노드의 수가 줄어듦
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려짐
- 레코드를 위한 인덱스 크기가 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어듦 -> 메모리 효율↓

#### 8.3.3.2 B-TREE 깊이
- 직접 제어할 방법이 없음
- 그림 8.7에서 키 값이 16바이트인 경우 최대 2억(585\*585\*585)개의 키 값을 가질 수 있지만 키 값이 32바이트면 5천만(372\*372\*372)개로 줄어듦
- B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결됨
- 인덱스 키 값의 크기↑ -> 인덱스 페이지가 담을 수 있는 키 값의 개수↓ -> B-Tree 깊이 깊어짐 -> 디스크 읽기 작업↑
- 인덱스 키 값 크기는 가능한 작게 만드는게 좋고, B-Tree 깊이는 5단계 이상 깊어지는 경우가 흔치 않음

#### 8.3.3.3 선택도(기수성)
- 인덱스에서 선택도(Selectivity) = 기수성(Cardinality) : 모든 인덱스 키 값 가운데 유니크한 값의 수
- 인덱스 키 값 가운데 중복된 값이 많아지면 기수성, 선택도↓
- 선택도↑ -> 검색 대상↓ -> 속도↑

#### 8.3.3.4 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 거솝다 높은 비용이 드는 작업
- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 비용 = 테이블에서 직접 레코드 1건 읽는 비용 * 4-5배 작업으로 예측
- 읽어야 할 레코드의 건수 > 전체 테이블 레코드의 20-25% -> 인덱스 사용X, 테이블을 직접 읽어 필요한 레코드만 가려내는(필터링) 방식이 효율적임