# 08장 인덱스

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

MySQL이 인덱스를 이용하는 대표적인 방법
- [인덱스 레인지 스캔](#8341-인덱스-레인지-스캔)
- [인덱스 풀 스캔](#8342-인덱스-풀-스캔)
- [루스 인덱스 스캔](#8343-루스-인덱스-스캔)
- [인덱스 스킵 스캔](#8344-인덱스-스킵-스캔)

#### 8.3.4.1 인덱스 레인지 스캔
검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식. 검색하는 값의 수나 검색 결과 레코드 건수와 상관 없이 레인지 스캔이라고 한다.

![인덱스를 이용한 레인지 스캔](./images/8-8.png)
그림 8.8 처럼 검색하는 레코드의 시작 지점을 찾은 후 끝 지점까지 순서대로 읽는다.

![인덱스 레인지 스캔을 통한 데이터 레코드 읽기](./images/8-9.png)
인덱스를 스캔하면서 레코드를 불러오는 경우 그림 8.9 처럼 불러온다. 그러니까 인덱스를 이용해 검색을 할 경우에 데이터 파일에서 레코드를 읽어오는 랜덤 I/O가 일어난다. 따라서, 읽어올 레코드가 20~25%를 넘으면 인덱스를 통하지 않고 테이블의 데이터를 직접 읽는 것이 더 효율적이다.

인덱스 레인지 스캔 동작 순서
1. 인덱스에서 조건에 맞는 위치를 찾는다. - 인덱스 탐색 (Index Seek)
2. 1번에서 찾은 위치부터 차례대로 읽는다. - 인덱스 스캔 (Index Scan)
3. 2번에서 읽은 인덱스 키와 레코드 주소를 이용해 페이지를 가져오고, 레코드를 읽는다.

검색할 데이터에 따라서 3번 과정이 필요하지 않는 경우도 있는데 이를 커버링 인덱스라고 한다. 즉, 랜덤 I/O가 없어서 속도가 빠르다.

#### 8.3.4.2 인덱스 풀 스캔
인덱스를 처음부터 끝까지 모두 읽는 방식. 대표적으로 쿼리의 조건절에 사용한 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 사용된다. 인덱스는 (A, B, c) 순서로 만들어져 있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우

쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 이 방식을 사용한다. 그러나 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식을 사용하지 않는다.

![인덱스 풀 스캔](./images/8-10.png)
그림 8.10 처럼 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동 후, 리프 노드를 따라서 스캔한다. 이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.

#### 8.3.4.3 루스 인덱스 스캔
오라클과 같은 DBMS의 "인덱스 스킵 스캔" 과 비슷한 동작을 한다. 루스 인덱스 스캔은 중간에 필요치 않은 인덱스 키 값은 무시하고 넘어가는 형태로 처리한다. 보통 `GROUP BY` 혹은 `MAX()`, `MIN()` 함수에 최적화를 할 때 사용한다.

```sql
SELECT DEPT_NO, MIN(EMP_NO)
FROM DEPT_EMP
WHERE EMP_NO BETWEEN 'd002' AND 'd004'
GROUP BY DEPT_NO;
```

![루스 인덱스 스캔](./images/8-11.png)
그림 8.11을 보면 불필요한 부분은 무시하고 필요한 부분만 읽는다.

#### 8.3.4.4 인덱스 스킵 스캔
인덱스는 값이 정렬되어 있는 것이 핵심이고, 이 때문에 인덱스를 구성하는 칼럼의 순서가 중요하다. 인덱스로 등록한 칼럼에 대한 조건이 일부 없는 쿼리는 인덱스를 "효율적으로" 사용할 수 없다. 즉, 인덱스에서 불필요한 부분도 접근하는 것을 의미한다.

MySQL 8.0 버전에서 이런 경우에도 칼럼을 건너뛰고 조건에 포함된 칼럼만으로 인덱스 검색이 가능한 '인덱스 스킵 스캔(Index Skip Scan)' 기능이 추가됐다.

![인덱스 스킵 스캔](./images/8-12.png)
> MySQL 서버는 인덱스를 루스 인덱스 스캔과 동일한 방식으로 읽으면서 인덱스에 존재하는 모든 값을 추출하고 그 결과를 이용하여 인덱스 스킵 스캔을 실행한다.

인덱스 스킵 스캔의 단점
- WHERE 조건절에 없는 인덱스 선행 칼럼의 유니크 값의 개수가 적어야 함
    - 유니크한 값의 개수가 너무 많으면 인덱스 시작 지점을 검색하는 작업이 많이 필요해진다.
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함 (커버링 인덱스)
    - 인덱스에 없는 칼럼을 필요할 경우 테이블 레코드를 읽어와야 한다.

### 8.3.5 다중 칼럼(Multi-column) 인덱스
두 개 이상의 칼럼으로 구성된 인덱스

![다중 칼럼 인덱스](./images/8-13.png)
다중 칼럼 인덱스의 정렬은 앞의 칼럼에 의존한다. 따라서 그림 8.13의 `emp_no - "10003"` 레코드의 경우 emp_no 값이 가장 작지만 제일 마지막에 존재한다. 따라서 인덱스 내에서 칼럼의 순서가 매우 중요하며, 신중하게 결정해야 한다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
인덱스는 설정한 정렬 규칙에 따라 오름차순이나 내림차순으로 저장된다. 그러나 읽는 방향은 쿼리에 따라 옵티마이저가 만드는 실행 계획에 따라 결정된다.

#### 8.3.6.1 인덱스의 정렬
MySQL 8.0 버전부터는 각 칼럼별로 정렬 규칙을 혼합해서 생성할 수 있다.

#### __인덱스 스캔 방향__
인덱스는 읽는 방향에 따라 오름차순 또는 내림차순의 효과를 얻을 수 있다.

```sql
SELECT *
FROM EMPLOYEES
ORDER BY FIRST_NAME DESC
LIMIT 1;
```

![인덱스의 오름차순과 내림차순 읽기](./images/8-14.png)
MySQL 옵티마이저는 그림 8.14 처럼 인덱스의 읽기 방향을 전환해서 최적화된 실행 계획을 만든다.

#### __내림차순 인덱스__
InnoDB는 인덱스 역순 스캔이 인덱스 정순 스캔보다 느릴 수 밖에 없다.
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

![InnoDB 페이지 내부의 레코드 간 연결](./images/8-16.png)
> 레코드들이 순서대로 저장된 것처럼 표시되지만 실제로는 Heap 처럼 사용돼서 물리적으로 순서대로 배치되지 않는다.

그러나 `ORDER BY ... DESC` 쿼리가 드물게 실행되면 내림차순 인덱스를 고려할 필요는 없다. 많은 쿼리가 인덱스의 앞쪽 또는 뒤쪽만 집중적으로 읽는 경우, 해당 순서대로 인덱스를 생성하여 잠금 병목 현상을 완화하는 데 도움이 된다.