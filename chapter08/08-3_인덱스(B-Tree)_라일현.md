## 8.6 함수 기반 인덱스
- 일반적인 인덱스는 칼럼의 값 일부 또는 전체에 대해서만 인덱스 생성 허용
- 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스 구축 - 함수 기반 인덱스 활용
- 함수 기반 인덱스를 구현하는 방법
	- 가상 칼럼을 이용한 인덱스
	- 함수를 이용한 인덱스

### 8.6.1 가상 칼럼을 이용한 인덱스

```
// 사용자 정보를 저장하는 테이블
mysql> CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	PRIMARY KEY (user_id)
);

// first_name과 last_name을 합쳐서 검색해야 하는 요건이 있다면 가상 칼럼 생성
mysql> ALTER TABLE user
	ADD full_name VARCHAR(30) AS (CONCAT(fisrt_name, ' ', last_name)) VIRTUAL,
	ADD INDEX ix_fullname (full_name);

mysql> EXPLAINE SELECT * FROM user WHERE full_name='Matt Lee';
```

- 가상 칼럼은 테이블에 새로운 칼럼을 추가하는 것과 같은 효과를 내서 실제 테이블의 구조가 변경된다는 단점이 존재

### 8.6.2 함수를 이용한 인덱스

```
// 테이블 구조를 변경하지 않고 함수를 직접 사용하는 인덱스 생성 가능
mysql> CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	PRIMARY KEY (user_id),
	INDEX ix_fullname ((CONCAT(first_name, ' ', last_name)))
);

// 함수 기반 인덱스를 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용되어야 함
// 아래의 예제는 옵티마이저가 표시하는 실행 계획이 ix_fullname 인덱스를 사용하지 않는 것으로 표시된다면 CONCAT 함수에 사용된 공백 문자 리터럴때문일 확률이 높음
// 그럴 경우 시스템 변수의 값을 동일 콜레이션으로 일치 시킨 후 다시 테스트 수행 (collation_connection, collation_database, collation_server)
mysql> EXPLAIN SELECT * FROM user WHERE CONCAT(first_name, ' ', last_name)='Matt Lee';
```

## 8.7 멀티 밸류 인덱스
- 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가짐(전문 검색 인덱스를 제외) - 인덱스 키 : 데이터 레코드 = 1 : 1
- 멀티 밸류 인덱스 : 하나의 데이터 레코드가 여러 개의 키 값을 가짐 - 인덱스 키 : 데이터 레코드 = N : 1
- JSON의 배열 타입 필드에 저장된 원소들에 대한 인덱스 요건을 만족하기 위함
```
// 테이블 구조를 변경하지 않고 함수를 직접 사용하는 인덱스 생성 가능
mysql> CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	credit_info JSON,
	INDEX mx_creditscores ((CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)))
);
mysql> INSERT INTO user VALUES (1, 'Matt', 'Lee', '{"credit_scores":[360, 353, 351]}')
```

## 8.8 클러스터링 인덱스
- 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현
- InnoDB 스토리지 엔진에서만 지원

### 8.8.1 클러스터링 인덱스 (클러스터링 테이블)
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정
- 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미
- InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 빠름
- B-Tree 인덱스를 클러스터링 인덱스라고 부르진 않음 (레코드가 프라이머리 키 값으로 정렬된 경우에만 클러스터링 인덱스)
- 프라이머리 키가 없는 경우
	1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
	2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
	3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후 클러스터링 키로 선택
	
### 8.8.2 세컨더리 인덱스에 미치는 영향
- 클러스터링되지 않은 테이블은 INSERT될 때 처음 저장된 공간에서 절대 이동하지 않음
- 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없음
- 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현

### 8.8.3 클러스터링 인덱스의 장점과 단점
- 장점
	- 빠른 읽기(SELECT)
	- 프라이머리 키로 검색할 때 처리 성능이 매우 빠름
- 단점
	- 느린 쓰기(INSERT, UPDATE, DELETE)
	- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값이 클 경우 전체적으로 인덱스 크기가 커짐

### 8.8.4 클러스터링 테이블 사용 시 주의사항

#### 8.8.4.1 클러스터링 인덱스 키의 크기
- 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커짐
- 테이블 세컨더리 인덱스가 4~5개정도 생성되는 것을 고려했을 때 세컨더리 인덱스 크기가 급격히 증가
- InnoDB 테이블의 프라이머리 키는 신중하게 선택해야 함

#### 8.8.4.2 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성
- 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 설정하는 것이 좋음

#### 8.8.4.3 프라이머리 키는 반드시 명시할 것
- 자동으로 추가된 칼럼은 사용자에게 보이지 않아 사용자가 접근할 수 없으므로 명시해주는 것이 좋음
- ROW 기반의 복제, InnoDB Cluster에서는 모든 테이블이 프라이머리 키를 가져야만 정상적인 복제 성능을 보장하기도 함

#### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
- 프라이머리 키의 크기가 길어도 세컨더리 인덱스가 필요치 않다면 그대로 프라이머리 키를 사용
- 인조식별자 : 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키
- INSERT 위주의 테이블들은 AUTO_INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움됨

## 8.9 유니크 인덱스
- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음
- MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음
- 유니크 인덱스에서 NULL도 저장될 수 있는데 NULL은 특정 값이 아니므로 2개 이상 저장 가능
- 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동 부여됨

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교
- 인덱스 구조상 아무런 차이점이 없음 (읽기와 쓰기 성능 관점에서 비교)

#### 8.9.1.1 인덱스 읽기
- 유니크 인덱스가 더 빠른 것은 아님
- 유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼을 비교하는 작업 -> 성능상 영향이 거의 없음

#### 8.9.1.2 인덱스 쓰기
- 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요
- 그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느림
- 유니크 인덱스에서 중복된 값을 체크할 때 읽기 잠금 사용하고, 쓰기할 때 쓰기 잠금 사용하는데 이 과정에서 데드락이 빈번히 발생

### 8.9.2 유니크 인덱스 사용 시 주의사항
- 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복 생성할 필요 없음
- 프라이머리 키와 유니크 인덱스를 동일하게 생성하는 경우도 있는데 이 또한 중복
- 유일성이 보장되어야 하는 칼럼은 유니크 인덱스를 생성하지만 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 고려하는게 좋음

## 8.10 외래키
- InnoDB 스토리지 엔진에서만 생성 가능
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스 삭제 불가능
- 외래키 관리의 중요한 특징
	- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)가 발생
	- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기) 발생시키지 않음
