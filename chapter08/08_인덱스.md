# 08 인덱스

## 8.1 디스크 읽기 방식

* 랜덤 I/O
* 순자 I/O

### 8.1.1 하드 디스크 드라이블와 솔리드 스테이트 드라이브

* 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는  SSD가 HDD와 성능차이 크지 x
* 랜덤 I/O에서는 SSD가 HDD보다 훨씬 빠르다

### 8.1.2 랜덤 I/O와 순차 I/O

* 랜덤 I/O와 순차 I/O의 차이점
  * 디스크에 기록해야할 위치를 찾기 위해 랜덤 I/O가 순차 I/O보다 디스크 기록을 위한 시스템 콜을 더 많이 요청한다. -> 디스크 헤더가 더 많이 움직인다.
  * 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의햐 결정된다.
  * 따라서 여러 번 쓰기 또는 읽기 요청하는 랜덤 I/O작업이 작업 부하가 훨씬 더 크다
  * 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적 -> 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 개선하는 것을 의미
    * 인덱스 레인지 스캔은 주로 랜덤I/O사용하고, 풀 스캔은 순차 I/O사용, 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.(순차I/O가 랜덤I/O보다 더 빨리 많은 레코드 읽어올 수 있기 때문에)

## 8.2 인덱스란?

* 인덱스는 칼럼의 값을 주어진 순서대로 미리 정렬해서 보관한다.
* SortedList - 인덱스와 같은 자료구조
  * 단점
    * 데이터가 저장될 때 마다 정렬, 복잡하고 느림
  * 장점
    * 아주 빨리 원하는 값 찾아올 수 있음
* ArrayList - 데이터 파일과 같은 자료구조

* 결론 -> DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 읽기 속도를 높이는 기능
* 인덱스 분류
  * 역할별 분류
    * 프라이머리 키 
    * 세컨더리 인덱스
    * 유니크 인덱스
  * 데이터 저장 방식별로 분류
    * B-Tree 인덱스
    * Hash 인덱스
  * 중복 허용 여부로 분류
    * 유니크 인덱스
    * 유니크 하지 않은 인덱스 
  * 기능별 분류
    * 전문 검색용 인덱스
    * 공간 검색용 인덱스 

## 8.2 B-Tree 인덱스

* 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지

### 8.3.1 구조 및 특성

* 루트 노드, 리프, 노트, 브랜치 노드
* 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
* 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장돼 있다.
* InnoDb 스토리지 엔진에서는 프라이머리 키가 ROWID 역할을 한다
* InnoDB 테이블의 세컨더리 인덱스는 논리적인 주소를 가진다(프라이머리 키가 ROWID의 역할 수행)
* 그래서 테이블에서 인덱스를 통해 레코드를 읽을 때 데이터 파일을 바로 찾아가지 못하고 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장된 레코드를 읽는다.
* 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree 를 다시 한번 검색해야 한다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 키 추가

* 저장될 키 값을 이용해 B-Tree상의 적절한 위치 검색
* 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장
* 리프 노드가 꽉 찼으면 리프 노드 분리(상위 브랜치 노드까지 처리 범위 넓어짐)
* InnoDB 스토리지 엔진은 필요한 경우 인덱스 키 추가 작업을 지연시켜 나중에 처리함
* 하지만 프라이머리 키, 유니크 인덱스의 경우 중복 체크 필요하기 때문에 즉시 추가/삭제

#### 8.3.2.2 인덱스 키 삭제

* 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 삭제 마크
* 마킹된 인덱스 키 공간은 방치 또는 재활용
* InnoDB에서 지연 처리 될 수 있으니 서버 내부적으로 처리하므로 큰 문제 x

#### 8.3.2.3 인덱스 키 변경

* 먼저 키 값을 삭제 후, 다시 새로운 키 값 추가

#### 8.3.2.4 인덱스 키 검색

* 트리 탐색
* B-Tree 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우 사용 가능
* 부등호 조건에서도 활용 가능
* 인덱스 구성하는 키 뒷부분만 검색하는 용도로는 인덱스 사용 불가
* 인덱스의 키 값이 변형된 후 비교하는 경우에는 B-Tree의 빠른 검색 기능 사용 불가

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

* 칼럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향 받는다.

#### 8.3.3.1 인덱스 키 값의 크기

* 하나의 인덱스 페이지에 저장할 수 있는 키 값 = 인덱스 페이지 크기 / (인덱스 키 값 크기 + 자식 노드 주소 영역의 크기)

#### 8.3.3.2 B-Tree 깊이

* 인덱스 키 값의 크기 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값 개수 적어지고, 같은 레코드 건수라 하더라도 B-Tree 의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.

#### 8.3.3.3 선택도(기수성)

* 전체 인덱스 키 값의 개수 / 유니크한 값의 개수

#### 8.3.3.4 읽어야 하는 레코드의 건수

* 인덱스 통해 레코드 읽는 작업의 비용 > 인덱스 거치지 않고 테이블 레코드 읽는 비용
* 인덱스를 이용한 읽기의 손익 분기점을 잘 판단해야 한다.
* 읽어야 할 레코드 건수가 전체 테이블 20~25% 를 넘어서면 인덱스를 이용하지 않고 테이블을 직접 읽는것이 효율적이다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

* 인덱스를 이용하는 대표적인 세 가지 방법

#### 8.3.4.1 인덱스 레인지 스캔

* 검색해야 할 인덱스의 범위가 결정됐을 때 사용
* 리프노드까지 찾아 들어가 필요한 레코드의 시작 지점 찾고 순서대로 읽는다.(스캔)
* 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔
* 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정 필요 -> 레코드 한 건 단위로 랜덤 I/O 한 번 씩 일어난다 -> 비용이 많이 드는 작업
* 인덱스 레인지 스캔이 거치는 3단계
  1. 저장된 위치 탐색
  2. 차례대로 스캔
  3. 저장된 페이지 가져와 최종 읽기
* 3번을 생략하는 것 커버링 인덱스, 성능 빨라짐

#### 8.3.4.2 인덱스 풀 스캔

* 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우
* 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 
* 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.(인덱스의 포함된 컬럼마능로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문)

#### 8.3.4.3 루스 인덱스 스캔

* 상반된 개념 : 타이트 인덱스 스캔
* 인덱스를 느슨하게 듬성듬성 읽는 것
* 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어감
* GROUP BY또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화 하는 경우에 사용

#### 8.3.4.4 인덱스 스킵 스캔

* 인덱스의 핵심 : 값이 정렬돼 있다는 것
* 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다
* 컬럼 여러개를 가진 인덱스의 뒷 순서 컬럼을 비교조건으로 사용하려면 앞순서 칼럼에 대한 비교조건도 필수적으로 있었어야 했다.
* 8.0 버전부터 옵티마이저가 칼럼을 건너뛰어 뒷 컬럼만으로 인덱스 검색을 가능하게 해주는 인덱스 스킵 스캔 최적화 기능 도입

```mysql
mysql> SELECT gender, birth_date FROM employees WHERE gender='M' AND birth_date>='1965-02-01'
mysql> SELECT gender, birth_date FROM employees WHERE gender='W' AND birth_date>='1965-02-01'
```

* gender컬럼을 사용 안하고 쿼리를 작성하면 내부적으로 위와 같이 gender 컬럼을 비교조건으로 사용하여 최적화를 실행
* 단점
  * where 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수 적어야 함
  * 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링인덱스)

### 8.3.5 다중칼럼 인덱스

* 두번째 칼럼은 첫번째 칼럼에 의존해서 정렬돼있음
* 다중 칼럼 인덱스에서는 인덱스 내 각 칼럼의 순서가 중요

### 8.3.6 B-Tree인덱스의 정렬 및 스캔 방향

#### 8.3.6.1 인덱스의 정렬

* 8.0 버전부터 정렬순서 혼합한 인덱스도 생성할 수 있게 됨

##### 8.3.6.1.1 인덱스 스캔 방향

* 인덱스는 항상 오름차순으로만 정렬돼 있지만 인덱스를 최솟값부터 읽으면 오름차순으로, 최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 옵티마이저가 알고 있다.
* 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.

##### 8.3.6.1.2 내림차순 인덱스

* 용어정리 
  * 오름차순 인덱스 : 작은 값의 인덱스 키가 B-Tree 왼쪽으로 정렬된 인덱스
  * 내림차순 인덱스 : 큰 값의 인덱스 키가 B-Tree 왼쪽으로 정렬된 인덱스
  * 인덱스 정순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
  * 인덱스 역순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔

* 내림차순 인덱스의 필요성
  * 하나의 인덱스를 정순으로 읽느냐 역순으로 읽느냐에 따라 시간 차이가 발생
* 실제 내부적으로 역순 스캔이 정순 스캔보다 느린 이유
  * 페이지 잠금이 인덱스 정순스캔에 적합한 구조
  * 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

#### 8.3.7 B-Tree 인덱스의 가용성과 효용성

#### 8.3.7.1 비교 조건의 종류와 효율성

```mysql 
mysql> SELECT * FROM dept_emp
	   WHERE dept_no = 'd002' AND emp_no >= 10114;
```

* 케이스 A : INDEX(dept_no, emp_no)
* 케이스 B : INDEX(emp_no, dept_no)
* 케이스 A는 dept_no = 'd002' emp_no >= 10114인 레코드를 찾고 이후에는 dept_no 가'd002' 가 아닐 때까지 인덱스를 쭉 읽기만 하면 된다.
* 하지만 케이스 B는 emp_no >= 10114 dept_no = 'd002'인 레코드를 찾고 이후 모든 레코드에 대해 dept_no = 'd002'인지 비교하는 과정을 거쳐야 한다
* 이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링 이라고 한다.
* 케이스 A 인덱스에서 emp_no는 비교작업의 범위를 좁히는데 도움을 주지만, 케이스 B의 dept_no는 범위를 좁히는 데 도움을 주지 못하고, 단지 쿼리의 조건에 맞는지 검사하는 용도로만 사용된다.
* 작업 범위결정 조건, 필터링조건(체크 조건)
* 작업범위를 결정하는 조건이 많을수록 쿼리의 처리 성능이 좋아지지만 체크조건은 많다고 해서 쿼리 성능이 좋아지지 않는다

#### 8.3.7.2 인덱스 가용성







## 8.6 함수 기반 인덱스 

* 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때 함수 기반 인덱스 활용
* 함수 기반 인덱스 구현 방법
  * 가상 칼럼 이용한 인덱스
  * 함수 이용한 인덱스 
* 함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이만 있을 뿐, 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree인덱스와 동일하다

### 8.6.1 가상 칼럼을 이용한 인덱스

*  칼럼을 새로 추가하고 모든 레코드에 대해 값을 없데이트하는 작업을 거칠 필요 없이 가상 칼럼만 추가하고 그 가상 칼럼에 인덱스 생성할 수 있게 됨
* 가상 칼럼은 테이블에 새로운 칼럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점있음

### 8.6.2 함수를 이용한 인덱스

* 8.0 버전부터 테이블의 구조를 변경하지 않고 함수를 직접 사용하는 인덱스 생성할 수 있게 됨
* 함수 기반 인덱스를 활용하려면 반드시 **조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.** 
* 표현식이 다르면 설령 결과가 같다고 하더라도 옵티마이저가 서로 다른 표현식으로 간주하기 때문

## 8.7 멀티 밸류 인덱스

* 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태
* JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건 발생

```mysql
mysql> CREATE TABLE user(
    ...
	INDEX mx_creditscores ( (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)))
    ...
    );
    
mysql> INSERT INTO user VALUES (1, 'Matt', 'Lee', '{"credit_scores":[360,353,351]}')
```

* 멀티밸류 인덱스를 활용하려면 다음 함수를 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.
  * MEMBER OF()
  * JSON_CONTAINS()
  * JSON_OVERLAPS()

```mysql
mysql> SELECT * FROM user WHERE 360 MEMBER OF(credit_info->'$.credit_scores');
```

## 8.8 클러스터링 인덱스

* **클러스터링은 테이블의 레코드를 비슷한(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현된다**
* **이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것**

### 8.8.1 클러스터링 인덱스

* 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
* **프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다**
* 즉, 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것의 의미
* 클러스터링 기준이 되는 프라이머리 키 = 클러스터링 키
* InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키 변경이 상대적으로 느리다

<img src=".\images\8-25.png" alt="김우림_1" style="zoom:35%;" />

* 클러스터링 테이블의 구조 자체는 일반 B-Tree 와 비슷하지만 세컨더리 인덱스를 위한 B-Tree 의 리프 노드와 달리 클러스터링 인덱스 리프 노드에는 레코드의 모든 칼럼이 같이 저장돼 있다.
* 즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것이다.
* 프라이머리 키가 없는 InnoDB 테이블이 클러스터링 테이블로 구성되는 방법
  * 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
  * NOT NULL 옵션의 유니크 인덱스 중에서 첫번째 인덱스를 클러스터링 키로 선택
  * 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택
    * 아무 의미 없는 숫자 값으로 클러스터링됨, 아무런 혜택을 제공하지 않음, 가능하면 프라이머리 키 명시적으로 생성하자

### 8.8.3 클러스터링 인덱스의 장단점

* 장점
  * 프라이머리 키로 검색할 때 처리 성능 매우 빠름
  * 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음ㄴ
* 단점
  * 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크키가 커짐
  * 세컨더리 인덱스를 통해 검색할때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
  * INSERT 할 때 프라이머리 키에 레코드의 저장 위치가 결정되기 때문에 처리 성능 느림
  * 프라이머리 키를 변경할 떄 레코드를 DELETE 하는 작업이 필요하기 때문에 처리 성능이 느림
* 장점 - 빠른 읽기 단점 - 느린 쓰기
* **웹 서비스와 같은 온라인 트랜잭션 환경 OLTP(Online Transaction Processiong)에서는 쓰기와 읽기의 비율이 2:8, 1:9 정도기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는것이 중요**

### 8.8.4 클러스터링 테이블 사용 시 주의사항

#### 8.8.4.1 클러스터링 인덱스 키의 크기

* 프라이머리 키가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다
* 일반적으로 테이블에 세컨더리 인덱스가 4~5개정도 생성, 세컨더리 인덱스 크기는 급격히 증가
* 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 더 필요해지므로 InnoDB 테이블의 프라이머리 키는 신중하게 선택해야 한다.

#### 8.8.4.2 프라이머리 키는 AUTIO_INCREMENT 보다는 업무적인 칼럼으로 생성

#### 8.8.4.3 프라이머리 키는 반드시 명시할 것

#### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

* 여러 컬럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어짐
* 프라이머리 키의 크기가 길어ㅓ도 세컨더리 인덱스가 필요하지 않다면 그대로 프라이머리 키를 사용하는 것이 좋다.
* 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고, 이를 프라이머리 키로 설정하면 된다.
* 프라이머리 키를 대체하기 위해 인위적으로 추가한 프라이머리 키를 인조 식별자 라고 한다
* **로그 테이블과 같이 조회보다는 INSERT위주의 테이블들은 AUTO_INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 좋음**

## 8.9 유니크 인덱스

* MyISAM 이나 MEMORY 테이블에서 프라이머리 키는 사실 NULL이 허용되지 않는 유니크 인덱스와 같지만 InnoDB 테이블의 프라이머리 키는 클러스터링 키의 역할도 하므로 유니크 인덱스와는 근복적으로 다르다.

#### 8.9.1.1 인덱스 읽기

* 유니크 인덱스와 유니크하지 않은 세컨더리 인덱스의 읽기 성능 차이는 거의 없다

#### 8.9.1.2 인덱스 쓰기

* 유니크 인덱스의 키 값을 쓸 떄는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하기 때문에 세컨더리 인덱스보다 느리다

### 8.9.2 유니크 인덱스 사용 시 주의사항

* 유니크 인덱스는 일반 다른 인덱스와 같은 역할 하므로 중복생성 할 필요 x
* 프라이머리 키 인덱스와 유니크 키 인덱스토 중복생성필요 x

## 8.10 외래키

* 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.
* 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.
* InnoDB 외래키 관리의 두가지 특징
  * 테이블의 변경이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다
  * 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)를 발생시키지 않는다.

### 8.10.1 자식 테이블의 변경이 대기하는 경우

* 자식 테이블의 외래 키 칼럼의 변경은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면 해당 쓰기 잠금이 해제될 때 까지 기다리게 됨

### 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

* 자식 테이블이 생성될 때 정의된 외래키의 특성 ON DELETE CASCADE 떄문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동 -> 자식 테이블의 해당 레코드에 대한 쓰기 잠금이 걸려 있으면 잠금이 해제될 때 까지 기다려야 됨