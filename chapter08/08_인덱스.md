# 08 인덱스

## 8.1 디스크 읽기 방식

* 랜덤 I/O
* 순자 I/O

### 8.1.1 하드 디스크 드라이블와 솔리드 스테이트 드라이브

* 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는  SSD가 HDD와 성능차이 크지 x
* 랜덤 I/O에서는 SSD가 HDD보다 훨씬 빠르다

### 8.1.2 랜덤 I/O와 순차 I/O

* 랜덤 I/O와 순차 I/O의 차이점
  * 디스크에 기록해야할 위치를 찾기 위해 랜덤 I/O가 순차 I/O보다 디스크 기록을 위한 시스템 콜을 더 많이 요청한다. -> 디스크 헤더가 더 많이 움직인다.
  * 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의햐 결정된다.
  * 따라서 여러 번 쓰기 또는 읽기 요청하는 랜덤 I/O작업이 작업 부하가 훨씬 더 크다
  * 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적 -> 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 개선하는 것을 의미
    * 인덱스 레인지 스캔은 주로 랜덤I/O사용하고, 풀 스캔은 순차 I/O사용, 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.(순차I/O가 랜덤I/O보다 더 빨리 많은 레코드 읽어올 수 있기 때문에)

## 8.2 인덱스란?

* 인덱스는 칼럼의 값을 주어진 순서대로 미리 정렬해서 보관한다.
* SortedList - 인덱스와 같은 자료구조
  * 단점
    * 데이터가 저장될 때 마다 정렬, 복잡하고 느림
  * 장점
    * 아주 빨리 원하는 값 찾아올 수 있음
* ArrayList - 데이터 파일과 같은 자료구조

* 결론 -> DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 읽기 속도를 높이는 기능
* 인덱스 분류
  * 역할별 분류
    * 프라이머리 키 
    * 세컨더리 인덱스
    * 유니크 인덱스
  * 데이터 저장 방식별로 분류
    * B-Tree 인덱스
    * Hash 인덱스
  * 중복 허용 여부로 분류
    * 유니크 인덱스
    * 유니크 하지 않은 인덱스 
  * 기능별 분류
    * 전문 검색용 인덱스
    * 공간 검색용 인덱스 

## 8.2 B-Tree 인덱스

* 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지

### 8.3.1 구조 및 특성

* 루트 노드, 리프, 노트, 브랜치 노드
* 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
* 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장돼 있다.
* InnoDb 스토리지 엔진에서는 프라이머리 키가 ROWID 역할을 한다
* InnoDB 테이블의 세컨더리 인덱스는 논리적인 주소를 가진다(프라이머리 키가 ROWID의 역할 수행)
* 그래서 테이블에서 인덱스를 통해 레코드를 읽을 때 데이터 파일을 바로 찾아가지 못하고 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장된 레코드를 읽는다.
* 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree 를 다시 한번 검색해야 한다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 키 추가

* 저장될 키 값을 이용해 B-Tree상의 적절한 위치 검색
* 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장
* 리프 노드가 꽉 찼으면 리프 노드 분리(상위 브랜치 노드까지 처리 범위 넓어짐)
* InnoDB 스토리지 엔진은 필요한 경우 인덱스 키 추가 작업을 지연시켜 나중에 처리함
* 하지만 프라이머리 키, 유니크 인덱스의 경우 중복 체크 필요하기 때문에 즉시 추가/삭제

#### 8.3.2.2 인덱스 키 삭제

* 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 삭제 마크
* 마킹된 인덱스 키 공간은 방치 또는 재활용
* InnoDB에서 지연 처리 될 수 있으니 서버 내부적으로 처리하므로 큰 문제 x

#### 8.3.2.3 인덱스 키 변경

* 먼저 키 값을 삭제 후, 다시 새로운 키 값 추가

#### 8.3.2.4 인덱스 키 검색

* 트리 탐색
* B-Tree 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우 사용 가능
* 부등호 조건에서도 활용 가능
* 인덱스 구성하는 키 뒷부분만 검색하는 용도로는 인덱스 사용 불가
* 인덱스의 키 값이 변형된 후 비교하는 경우에는 B-Tree의 빠른 검색 기능 사용 불가

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

* 칼럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향 받는다.

#### 8.3.3.1 인덱스 키 값의 크기

* 하나의 인덱스 페이지에 저장할 수 있는 키 값 = 인덱스 페이지 크기 / (인덱스 키 값 크기 + 자식 노드 주소 영역의 크기)

