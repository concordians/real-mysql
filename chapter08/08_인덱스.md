# 08 인덱스

## 8.1 디스크 읽기 방식

* 랜덤 I/O
* 순자 I/O

### 8.1.1 하드 디스크 드라이블와 솔리드 스테이트 드라이브

* 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는  SSD가 HDD와 성능차이 크지 x
* 랜덤 I/O에서는 SSD가 HDD보다 훨씬 빠르다

### 8.1.2 랜덤 I/O와 순차 I/O

* 랜덤 I/O와 순차 I/O의 차이점
  * 디스크에 기록해야할 위치를 찾기 위해 랜덤 I/O가 순차 I/O보다 디스크 기록을 위한 시스템 콜을 더 많이 요청한다. -> 디스크 헤더가 더 많이 움직인다.
  * 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의햐 결정된다.
  * 따라서 여러 번 쓰기 또는 읽기 요청하는 랜덤 I/O작업이 작업 부하가 훨씬 더 크다
  * 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적 -> 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 개선하는 것을 의미
    * 인덱스 레인지 스캔은 주로 랜덤I/O사용하고, 풀 스캔은 순차 I/O사용, 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.(순차I/O가 랜덤I/O보다 더 빨리 많은 레코드 읽어올 수 있기 때문에)

## 8.2 인덱스란?

* 인덱스는 칼럼의 값을 주어진 순서대로 미리 정렬해서 보관한다.
* SortedList - 인덱스와 같은 자료구조
  * 단점
    * 데이터가 저장될 때 마다 정렬, 복잡하고 느림
  * 장점
    * 아주 빨리 원하는 값 찾아올 수 있음
* ArrayList - 데이터 파일과 같은 자료구조

* 결론 -> DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 읽기 속도를 높이는 기능
* 인덱스 분류
  * 역할별 분류
    * 프라이머리 키 
    * 세컨더리 인덱스
    * 유니크 인덱스
  * 데이터 저장 방식별로 분류
    * B-Tree 인덱스
    * Hash 인덱스
  * 중복 허용 여부로 분류
    * 유니크 인덱스
    * 유니크 하지 않은 인덱스 
  * 기능별 분류
    * 전문 검색용 인덱스
    * 공간 검색용 인덱스 

## 8.2 B-Tree 인덱스

* 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지

### 8.3.1 구조 및 특성

* 루트 노드, 리프, 노트, 브랜치 노드
* 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
* 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장돼 있다.
* InnoDb 스토리지 엔진에서는 프라이머리 키가 ROWID 역할을 한다
* InnoDB 테이블의 세컨더리 인덱스는 논리적인 주소를 가진다(프라이머리 키가 ROWID의 역할 수행)
* 그래서 테이블에서 인덱스를 통해 레코드를 읽을 때 데이터 파일을 바로 찾아가지 못하고 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장된 레코드를 읽는다.
* 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree 를 다시 한번 검색해야 한다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 키 추가

* 저장될 키 값을 이용해 B-Tree상의 적절한 위치 검색
* 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장
* 리프 노드가 꽉 찼으면 리프 노드 분리(상위 브랜치 노드까지 처리 범위 넓어짐)
* InnoDB 스토리지 엔진은 필요한 경우 인덱스 키 추가 작업을 지연시켜 나중에 처리함
* 하지만 프라이머리 키, 유니크 인덱스의 경우 중복 체크 필요하기 때문에 즉시 추가/삭제

#### 8.3.2.2 인덱스 키 삭제

* 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 삭제 마크
* 마킹된 인덱스 키 공간은 방치 또는 재활용
* InnoDB에서 지연 처리 될 수 있으니 서버 내부적으로 처리하므로 큰 문제 x

#### 8.3.2.3 인덱스 키 변경

* 먼저 키 값을 삭제 후, 다시 새로운 키 값 추가

#### 8.3.2.4 인덱스 키 검색

* 트리 탐색
* B-Tree 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우 사용 가능
* 부등호 조건에서도 활용 가능
* 인덱스 구성하는 키 뒷부분만 검색하는 용도로는 인덱스 사용 불가
* 인덱스의 키 값이 변형된 후 비교하는 경우에는 B-Tree의 빠른 검색 기능 사용 불가

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

* 칼럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향 받는다.

#### 8.3.3.1 인덱스 키 값의 크기

* 하나의 인덱스 페이지에 저장할 수 있는 키 값 = 인덱스 페이지 크기 / (인덱스 키 값 크기 + 자식 노드 주소 영역의 크기)

#### 8.3.3.2 B-Tree 깊이

* 인덱스 키 값의 크기 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값 개수 적어지고, 같은 레코드 건수라 하더라도 B-Tree 의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.

#### 8.3.3.3 선택도(기수성)

* 전체 인덱스 키 값의 개수 / 유니크한 값의 개수

#### 8.3.3.4 읽어야 하는 레코드의 건수

* 인덱스 통해 레코드 읽는 작업의 비용 > 인덱스 거치지 않고 테이블 레코드 읽는 비용
* 인덱스를 이용한 읽기의 손익 분기점을 잘 판단해야 한다.
* 읽어야 할 레코드 건수가 전체 테이블 20~25% 를 넘어서면 인덱스를 이용하지 않고 테이블을 직접 읽는것이 효율적이다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

* 인덱스를 이용하는 대표적인 세 가지 방법

#### 8.3.4.1 인덱스 레인지 스캔

* 검색해야 할 인덱스의 범위가 결정됐을 때 사용
* 리프노드까지 찾아 들어가 필요한 레코드의 시작 지점 찾고 순서대로 읽는다.(스캔)
* 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔
* 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정 필요 -> 레코드 한 건 단위로 랜덤 I/O 한 번 씩 일어난다 -> 비용이 많이 드는 작업
* 인덱스 레인지 스캔이 거치는 3단계
  1. 저장된 위치 탐색
  2. 차례대로 스캔
  3. 저장된 페이지 가져와 최종 읽기
* 3번을 생략하는 것 커버링 인덱스, 성능 빨라짐

#### 8.3.4.2 인덱스 풀 스캔

* 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우
* 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 
* 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.(인덱스의 포함된 컬럼마능로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문)

#### 8.3.4.3 루스 인덱스 스캔

* 상반된 개념 : 타이트 인덱스 스캔
* 인덱스를 느슨하게 듬성듬성 읽는 것
* 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어감
* GROUP BY또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화 하는 경우에 사용

#### 8.3.4.4 인덱스 스킵 스캔

* 인덱스의 핵심 : 값이 정렬돼 있다는 것
* 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다
* 컬럼 여러개를 가진 인덱스의 뒷 순서 컬럼을 비교조건으로 사용하려면 앞순서 칼럼에 대한 비교조건도 필수적으로 있었어야 했다.
* 8.0 버전부터 옵티마이저가 칼럼을 건너뛰어 뒷 컬럼만으로 인덱스 검색을 가능하게 해주는 인덱스 스킵 스캔 최적화 기능 도입

```mysql
mysql> SELECT gender, birth_date FROM employees WHERE gender='M' AND birth_date>='1965-02-01'
mysql> SELECT gender, birth_date FROM employees WHERE gender='W' AND birth_date>='1965-02-01'
```

* gender컬럼을 사용 안하고 쿼리를 작성하면 내부적으로 위와 같이 gender 컬럼을 비교조건으로 사용하여 최적화를 실행
* 단점
  * where 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수 적어야 함
  * 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링인덱스)

### 8.3.5 다중칼럼 인덱스

* 두번째 칼럼은 첫번째 칼럼에 의존해서 정렬돼있음
* 다중 칼럼 인덱스에서는 인덱스 내 각 칼럼의 순서가 중요

### 8.3.6 B-Tree인덱스의 정렬 및 스캔 방향

#### 8.3.6.1 인덱스의 정렬

* 8.0 버전부터 정렬순서 혼합한 인덱스도 생성할 수 있게 됨

##### 8.3.6.1.1 인덱스 스캔 방향

* 인덱스는 항상 오름차순으로만 정렬돼 있지만 인덱스를 최솟값부터 읽으면 오름차순으로, 최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 옵티마이저가 알고 있다.
* 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.

##### 8.3.6.1.2 내림차순 인덱스

* 용어정리 
  * 오름차순 인덱스 : 작은 값의 인덱스 키가 B-Tree 왼쪽으로 정렬된 인덱스
  * 내림차순 인덱스 : 큰 값의 인덱스 키가 B-Tree 왼쪽으로 정렬된 인덱스
  * 인덱스 정순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
  * 인덱스 역순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔

* 내림차순 인덱스의 필요성
  * 하나의 인덱스를 정순으로 읽느냐 역순으로 읽느냐에 따라 시간 차이가 발생
* 실제 내부적으로 역순 스캔이 정순 스캔보다 느린 이유
  * 페이지 잠금이 인덱스 정순스캔에 적합한 구조
  * 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조