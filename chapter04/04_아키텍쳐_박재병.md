# __04장 아키텍쳐__

## 4.1 MySQL 엔진 아키텍쳐

### __4.1.1 MySQL 의 전체 구조__
MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.

#### __4.1.1.1 MySQL 엔진__
MySQL 엔진은 클라이언트의 접속과 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 쿼리의 실행을 최적화하는 옵티마이저로 이루어진다. 또한 표준 SQL 문법을 지원하여 이를 따르는 쿼리는 타 DBMS와 호환된다.

#### __4.1.1.2 스토리지 엔진__
MySQL 엔진은 쿼리를 수행하고, 데이터를 디스크에 저장하거나 디스크로부터 읽어오는 부분은 스토리지 엔진이 전담한다. MySQL 에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 테이블이 사용할 스토리지 엔진을 지정하여 해당 테이블의 모든 IO 작업을 지정한 스토리지 엔진이 처리할 수 있다.

#### __4.1.1.3 핸들러 API__
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을 때 스토리지 엔진에 요청하는데, 이러한 요청을 핸들러 요청이라 하고 여기서 사용하는 API를 핸들러 API라고 한다. 즉, MySQL 엔진과 스토리지 엔진은 핸들러 API 를 이용해 데이터를 주고 받는다.

### __4.1.2 MySQL 스레딩 구조__
MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드 스레드과 백그라운드 스레드로 구분한다.

#### __4.1.2.1 포그라운드 스레드__
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 클라이언트 사용자가 요청하는 쿼리를 처리한다. MySQL에서 포그라운드 스레드는 사용자가 요청한 작업을 처리하기 때문에 사용자 스레드라고도 한다.

#### __4.1.2.2 백그라운드 스레드__
MyISAM 과는 다르게 InnoDB 에서는 다음의 여러 작업을 백그라운드로 처리한다.
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- Inno DB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

### __4.1.3 메모리 할당 및 사용 구조__
MySQL 의 메모리 공간은 글로벌 영역과 로컬 영역으로 구분한다.
글로벌 영역은 MySQL 서버가 시작되면서 운영체제가 할당한다. 두 영역은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

#### __4.1.3.1 글로벌 메모리 영역__
클라이언트 스레드 수와 무관하게 하나의 영역만 할당된다. 필요에 따라 N개의 영억을 할당할 수 잇지만 스레드와는 무관하다.

대표적인 글로벌 메모리 영역
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### __4.1.3.2 로컬 메모리 영역__
클라이언트 스레드가 쿼리를 처리할 때 사용하는 영역이다. 클라이언트 메모리 영역이라고도 한다. 또한 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 세션 메모리 영역이라고도 표현한다.

대표적인 로컬 메모리 영역
- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### __4.1.4 플러그인 스토리지 엔진 모델__
MySQL은 플러그인 API를 제공해서 서버의 기능을 커스텀하게 확장하거나 완전히 새로운 기능을 구현할 수 있다.

### __4.1.5 컴포턴트__
MySQL 8.0 부터는 기존의 플러그인 아키텍쳐를 대체하는 컴포넌트 아키텍쳐를 지원한다.
컴포넌트는 다음의 플러그인의 단점을 보완했다.
- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 불가능
- MySQL 서버의 변수나 함수를 직접 호출하여 안전하지 않음
- 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

### __4.1.6 쿼리 실행 구조__
(사용자) -> SQL 요청 -> 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리실행기 - ( 스토리지 엔진 ) -> SQL 결과 (사용자)

#### __4.1.6.1 쿼리 파서__
사용자가 요청한 쿼리 문장을 MySQL이 인식할 수 있는 최소 단위인 토큰으로 분리해 트리 형태의 구조로 만드는 작업을 처리한다. 기본 문법 오류를 검출한다.

#### __4.1.6.2 전처리기__
파서가 만들어준 트리를 기반으로 쿼리에 있는 구조적인 문제를 확인한다. 테이블 이름, 칼럼 이름, 내장 함수와 같은 개체를 매핑해서 객체의 존재 여부와 접근 권한 등을 확인한다.

#### __4.1.6.3 옵티마이저__
쿼리를 가장 저렴한 비용으로 빠르게 처리할지 결정하는 역할을 수행하며, DBMS의 두뇌에 해당된다.

#### __4.1.6.4 실행 엔진__
실행 엔진과 핸들러는 손과 발에 비유할 수 있다. 실행 엔진은 옵티마이저가 만든 실행 계획대로 핸들러에게 요청하여 받은 결과를 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

#### __4.1.6.5 핸들러 (스토리지 엔진)__
MySQL 엔진의 요청에 따라 데이터를 디스크에 쓰고 읽어 오는 역할을 담당한다.

### __4.1.7 복제__
복제는 매우 중요한 역할을 담당한다.

### __4.1.8 쿼리 캐시__
MySQL 서버에서 쿼리 캐시는 빠른 응답을 요구하는 서비스에서 매우 중요한 역할을 담당 했다. 실행 결과를 메모리에 캐시하고, 동일한 실행의 경우 메모리에서 즉시 반환하여 매우 빠른 응답을 보인다. 그러나 데이터의 변경은 거의 없고 읽기만 하는 서비스는 흔치 않아서 MySQL 8.0 에서 완전히 제거되었다.

### __4.1.9 스레드 풀__
스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드의 개수를 조절하여 동시 요청이 많아져도 서버의 CPU 가 제한된 스레드 처리에 집중하도록 하여 자원 소모를 줄이는 것이 목적이다.

### __4.1.10 트랜잭션 지원 메타데이터__
테이블의 구조 정보와 스토어드 프로그램 등의 정보를 메타데이터 라고 하는데, 이를 5.7 버전까지는 파일에 저장하였다. 하지만 파일은 트랜잭션을 지원하지 않아서 메타데이터가 변경될 때 서버가 비정상 종료되면 일관되지 않은 상태로 남는 문제가 발생했다. '데이터베이스나 테이블이 깨졌다'로 표현.
이를 위해 8.0 부터는 메타데이터를 InnoDB의 테이블에 저장하도록 개선했다.

메타데이터를 트랜잭션 기반의 InnoDB 스토리지에 저장하도록 개선하여 데이터베이스가 깨지는 문제를 유발하지 않게 되었다.

***
## 4.2 InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그로 인해 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### __4.2.1 프라이머리 키에 의한 클러스터링__
InnoDB의 모든 테이블은 프라이머리 키를 기준으로 클러스터링되어 저장된다.
- 프라이머리 키 값의 순서대로 디스크에 저장
- 모든 세컨더리 인덱스는 프라이머리 키의 값을 논리적인 주소로 사용
- 프라이머리 키를 이용한 레인지 스캔은 빠르게 처리
- 오라클 DBMS의 IOT와 동일한 구조

이런 특성 때문에 쿼리 실행 계획에서 프라이머리 키는 다른 인덱스에 비해 비중이 높게 설정된다.

### __4.2.2 외래 키 지원__
InnoDB 스토리지 엔진 레벨에서 외래 키를 지원한다. MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.

### __4.2.3 MVCC (Multi Version Concurrency Control)__
레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능으로 잠금을 사용하지 않는 일관된 읽기를 제공한다. 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다.

InnoDB는 언두 로그를 이용해 이 기능을 구현한다. 한 트랜잭션이 데이터를 변경할 때 다른 트랜잭션이 읽기 요청을 할 경우, 트랜잭션의 격리 수준에 따라서 버퍼 풀 혹은 언두 로그 영역의 데이터를 읽어서 반환한다.

### __4.2.4 잠금 없는 일관된 읽기__
InnoDB 엔진은 MVCC 를 이용해 잠금을 걸지 않고 읽기 작업을 수행한다. 잠금을 걸지 않기 때문에 읽기 작업은 다른 트랜잭션을 기다리지 않고 데이터를 조회한다. 격리 수준이 `SERIALIZABLE` 이거나 `INSERT 와 연결된 SELECT 작업`은 다른 트랜잭션의 변경 작업의 잠금을 대기한다.

### __4.2.5 자동 데드락 감지__
내부적으로 잠금의 데드락을 감지하기 위해 잠금 대기 목록을 그래프 형태로 관리한다. 데드락 감지 스레드가 주기적으로 대기 목록을 검사해서 언두 로그 레코드를 적게 가진 데드락 트랜잭션을 강제 종료한다. 이는 언두 처리할 내용이 적어 강제 롤백으로 인한 부하가 적게 발생하기 때문이다.

### __4.2.6 자동화된 장애 복구__
MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 복구 작업이 자동으로 진행된다.

InnoDB 엔진은 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않는다. 그러나 디스크나 서버 하드웨어 이슈 등으로 엔진이 자동으로 복구를 못하는 경우가 발생할 수 있는데, `innodb_force_recovery` 변수를 설정 후 서버를 시작해서 복구 작업을 진행해야 한다. 이 값은 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 한다. 이 때 1부터 6까지 값을 변경하면서 작업을 진행할 수 있으며, 0이 아닌 값에서는 `SELECT` 이외의 쿼리는 수행할 수 없다.

### __4.2.7 InnoDB 버퍼 풀__
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 또한, 디스크 쓰기 작업을 지연시키고 일괄 작업으로 처리하는 버퍼 역할도 같이 한다.

#### __4.2.7.1 버퍼 풀의 크기 설정__
버퍼 풀의 크기는 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해서 설정해야 한다. 버퍼 풀은 `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있고, 동적으로 버퍼 풀의 크기를 확장할 수 있다. InnoDB 버퍼 풀은 버퍼 풀 전체를 관리하는 잠금에 대한 경합을 줄이기 위해 여러 개로 쪼개어 관리할 수 있도록 개선되었다. 분리된 각 버퍼 풀을 버퍼 풀 인스턴스라고 표현한다.

#### __4.2.7.2 버퍼 풀의 구조__
InnoDB 엔진은 버퍼 풀을 페이지 크기의 조각으로 쪼개고 데이터 요청에 따라 해당 데이터 페이지를 읽어서 각 조각에 저장한다. 이를 위해 다음의 자료구조를 관리한다.
- LRU 리스트: 정확히는 LRU + MRU, 디스크에서 불러온 페이지를 최대한 메모리에 유지하여 디스크 읽기를 최소화
- 플러시 리스트: 디스크로 동기화되지 않은 데이터를 가진 페이지의 변경 시점 기준의 페이지 목록 관리
- 프리 리스트: 비어 있는 페이지 목록, 쿼리가 새로운 페이지를 읽어올 때 사용

#### __4.2.7.3 버퍼 풀과 리두 로그__
버퍼 풀과 리두 로그는 매우 밀접한 관계. 버퍼 풀은 데이터 캐시와 쓰기 버퍼링을 통해 성능을 향상시키는데, 메모리만 늘리면 데이터 캐시 성능만 향상된다. 따라서 리두 로그와의 관계를 이해해야 쓰기 버퍼링의 성능도 향상시킬 수 있다.

버퍼 풀은 전혀 디스크에서 읽은 상태에서 변경되지 않은 클린 페이지와 변경된 더티 페이지를 가지고 있다. 리두 로그는 1개 이상의 고정 크기 파일을 연결하여 순환 고리형태로 사용한다. 즉, 언젠가는 새로운 리두 로그 엔트리로 덮어 쓰인다. 따라서 재사용 가능한 공간과 재사용 불가능한 공간인 활성 리두 로그로 구분하여 관리한다.

리두 로그는 공간의 관리를 위해 LSN (Log Sequence Number)를 로그 포지션으로 사용한다. InnoDB 는 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화시키며 가장 최근의 LSN이 리두 로그 시작점이다.
> 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN 차이 = 체크포인트 에이지

*체크포인트 에이지 = 활성 리두 로그 공간의 크기*

버퍼 풀에 더티 페이지의 비율이 너무 높은 상태에서 버퍼 풀이 필요해지면 매우 많은 더티 페이지를 한 번에 기록해야 한다. 따라서 리두 로그 파일의 전체 크기를 조절하면서 최적값을 선택해야 한다.

#### __4.2.7.4 버퍼 풀 플러시__
버퍼 풀에서 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 2가지의 플러시 기능을 백그라운드로 실행한다.
- 플러시 리스트 플러시
> 플러시 리스트에서 오래전에 변경된 데이터 페이지를 순서대로 디스크에 동기화한다.
>
> 동기화하는 스레드인 클리너 스레드의 개수를 조절하여, 여러 개의 버퍼 풀 인스턴스를 동시에 사용할 수 있다. 이 때에, 한 스레드당 하나의 인스턴스를 처리하도록 시스템 변수를 설정할 필요가 있다.
- LRU 리스트 플러시
> 사용 빈도가 낮은 데이터 페이지를 제거해서 새로운 페이지를 읽어올 공간을 만들 때 사용한다.
>
> `innodb_lru_scan_depth` 변수 만큼 스캔하며 더티 페이지는 디스크에 동기화시키고, 클린 페이지는 프리 리스트로 옮긴다. 각 버퍼 풀 인스턴스 별로 스캔하기 때문에 `버퍼 풀 인스턴스 수 * 스캔 범위` 만큼 수행한다.

#### __4.2.7.5 버퍼 풀 상태 백업 및 복구__
MySQL 서버를 재시작하는 경우 InnoDB 버퍼 풀의 상태를 백업할 수 있다. 그리고 재시작하면 버퍼 풀의 상태를 복구하는데, 이처럼 디스크의 데이터가 버퍼 풀에 적재된 상태를 `워밍업` 이라고 표현한다. 

버퍼 풀 백업은 데이터 페이지의 메타 정보만 저장하므로 백업은 빠르게 완료되지만, 디스크로부터 다시 읽어와야 하므로 복원은 시간이 걸릴 수 있다.

#### __4.2.7.6 버퍼 풀의 적재 내용 확인__
`information_schema 데이터베이스의 innodb_cached_indexes 테이블`을 이용하여 테이블의 인덱스별로 데이터 페이지가 얼마나 버퍼 풀에 적재되어 있는지 확인할 수 있다.

### __4.2.8 Double Write Buffer__
리두 로그는 페이지의 변경된 내용만 기록한다. 이로 인해 디스크 파일로 동기화할 때에 하드웨어 오작동 혹은 시스템의 비정상 종료 등으로 문제가 발생하면 페이지의 내용을 복구하지 못할 수도 있다. 이를 방지하기 위해 Double_Write 기법을 이용한다. 

변경 내용을 기록하기 전에 먼저 더티 페이지를 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다. 그 다음 각 더티 페이지를 랜덤으로 쓰기를 실행한다.

### __4.2.9 언두 로그__
트랜잭션과 격리 수준을 보장하기 위해 DML ( `INSERT, UPDATE, DELETE` ) 로 변경되기 이전의 데이터를 별도로 백업한다. 이렇게 백업된 데이터를 언두 로그라고 한다.

언두 로그 사용 목적
- 트랜잭션 보장: 트랜잭션 롤백 시에 언두 로그에 백업된 데이터를 이용한다.
- 격리 수준 보장: 특정 트랜잭션이 데이터를 변경 중일 때에 다른 커넥션의 조회에 대해 격리 수준에 따라 변경 중인 데이터를 읽지 않고, 언두 로그의 데이터를 읽어서 반환하기도 한다.

#### __4.2.9.1 언두 로그 레코드 모니터링__
대용량의 데이터를 처리하는 트랜잭션뿐만 아니라 트랜잭션이 오랜 시간 동안 실행될 때도 언두 로그의 양은 급격히 증가할 수 있다. 트랜잭션이 완료되어도 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아니다.

> 사용자의 실수로 트랜잭션을 시작한 상태에서 완료하지 않고 하루 정도 방치한 상황을 가정한 경우.
이 트랜잭션이 시작된 시점부터 생성된 언두 로그를 계속 유지할 것이다. 결국 언두 로그는 하루동안 일어난 모든 데이터 변경을 저장하게 되고, 언두 로그의 저장 공간은 계속 증가할 것이다. 단순히 저장 공간의 증가만은 문제가 안될 수 있지만 변경된 레코드를 조회하는 쿼리가 빈번하게 실행되면 언두 로그의 이력을 필요한 만큼 스캔해야 하므로 쿼리의 성능이 매우 떨어지게 된다.

MySQL 8.0 에서는 언두 로그를 돌아가면서 순차적으로 사용, 필요한 시점에 사용 공간을 자동으로 줄이는 방법 등으로 위의 문제점을 해결하였다. 그럼에도 불구하고 트랜잭션을 장시간 유지하는 것은 성능상 좋지 않다. 따라서 *__언두 로그의 레코드가 얼마나 되는지 항상 모니터링하는 것이 좋다.__*

#### __4.2.9.2 언두 테이블스페이스 관리__
언두 로그가 저장되는 공간을 언두 테이블스페이스 라고 한다. 언두 테이블스페이스는 1개 ~ 128개 의 롤백 세그먼트를 가지며 각 세그먼트는 1개 이상의 언두 슬롯을 가진다. 하나의 트랜잭션이 필요로 하는 언두 슬롯의 갯수는 문장의 특성에 따라 최대 4개까지 사용한다.

하나의 세그먼트가 가지는 언두 슬롯 갯수: 페이지 크기를 16바이트로 나눈 값 ex) 페이지 크기가 16KB - 언두 슬롯 1024개

최대 동시 처리 가능한 트랜잭션의 갯수는 다음 수식으로 예측할 수 있다.
> *InnoDB 페이지 크기 / 16 * 롤백 세그먼트 갯수 * 언두 테이블스페이스 갯수*

언두 테이블스페이스 공간에서 불필요하거나 과도하게 할당된 공간을 OS에 반납하는 것을 `Undo tablespace truncate` 라고 한다.
- 자동 모드: 퍼지 스레드 (Purge Thread) 가 주기적으로 불필요한 언두 로그를 삭제하는 작업을 실행한다.
- 수동 모드: 자동으로 실행되지 않거나 공간 반납이 부진한 경우, 언두 테이블스페이스를 강제로 비활성화하면 퍼지 스레드는 비활성화된 언두 테이블스페이스를 찾아서 OS로 반납한다. 이후에 언두 테이블스페이스를 다시 활성화한다. 단, 수동 모드는 언두 테이블스페이스가 3개 이상이어야 한다.

```SQL
ALTER UNDO TABLESPACE tablespace_name SET INACTIVE;
// 퍼지 스레드에 의해 언두 테이블스페이스 공간 반납.
ALTER UNDO TABLESPACE tablespace_name SET ACTIVE;
```
***

### __4.2.10 체인지 버퍼__
레코드가 INSERT되거나 UPDATE될 때에는 데이터 파일을 변경뿐 아니라 테이블에 포함된 인덱스를 업데이트 해야 한다. 인덱스 업데이트 또한 디스크를 읽어야 하므로 버퍼 풀에 있을 경우 즉시 업데이트를 수행하고, 그렇지 않다면 임시 공간에 저장해 두고 결과를 반환한다. 이 공간이 체인지 버퍼이다.

중복 체크를 해야하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다. 체인지 버퍼의 레코드 조각을 디스크로 동기화하는 백그라운드 스레드는 체인지 버퍼 머지 스레드이다.

체인지 버퍼는 버퍼 풀 공간의 25%까지 사용하며 최대 50% 까지 조절할 수 있다.

### __4.2.11 리두 로그 및 로그 버퍼__
리두 로그는 트랜잭션의 4가지 요소 (ACID) 중에 D(Durable)에 해당하는 영속성과 가장 밀접하다. 서버가 비정상 종료되어도 데이터를 읽지 않게 해주는 안전장치.

대부분의 데이터베이스 서버는 변경 내용을 로그로 기록한다. 데이터 파일은 읽기 성능이 우선되어 있어 쓰기 비용이 상대적으로 크다. 따라서 쓰기 비용이 낮은 구조인 리두 로그를 가지고 있으며, 비정상 종료시에 리두 로그를 이용해 복구한다. 또한, 리두 로그를 버퍼링할 수 있는 버퍼 풀이나 로그 버퍼를 가지고 있다.

#### __4.2.11.1 리두 로그 아카이빙__
InnoDB 엔진의 리두 로그에 쌓인 내용을 계속 추적하면서 새로 추가된 리두 로그 엔트리를 복사하여 백업한다.

#### __4.2.11.2 리두 로그 활성화 및 비활성화__
MySQL 서버에서 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않지만, 리두 로그 (트랜잭션 로그)는 항상 기록된다. 데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화해서 데이터의 적재 시간을 단축시킬 수 있다.

### __4.2.12 어댑티브 해시 인덱스__
일반적인 인덱스는 테이블에 사용자가 생성한 B-Tree 인덱스를 의미한다. 어댑티브 해시 인덱스는 사용자가 자주 요청한 데이터에 대해 자동으로 생성한 인덱스이다. 자주 조회하는 데이터 페이지의 키 값을 이용해 해시 인덱스를 생성해서 즉지 찾아갈 수 있다. 또한, B-Tree의 노드를 탐색하며 찾아가는 비용이 사라진다. 해시 인덱스는 `B-Tree 인덱스의 고유번호와 B-Tree 인덱스의 실제 키 값` 그리고 해당 키 값이 저장된 `데이터 페이지의 주소` 쌍으로 관리된다.

어댑티브 해시 인덱스가 도움되지 않는 경우
- 디스크 읽기가 많은 경우
- 조인이나 LIKE 패턴 검색 등 특정 패턴의 쿼리가 많은 경우
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

크게 도움되는 경우
- 디스크의 데이터가 버퍼 풀 크기와 비슷한 경우
- 동등 비교와 IN 연산 등 동등 조건 검색이 많은 경우
- 쿼리가 데이터 중 일부에만 집중되는 경우

MySQL 서버의 상태 값을 확인하여 해시 인덱스를 사용하는 게 효율적인지 비효율적인지 판단하여 비활성화하는 것이 좋을 수도 있다.

### __4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교__
InnoDB 엔진이 개선되는 만큼 MyISAM 엔진의 기능은 도태되는 상황이며, 이후에는 없어질 것으로 예상한다. MyISAM 만의 장점이 없어졌기 때문이다.

MEMORY 엔진은 동시 처리 성능이 매우 중요한 온라인 트랜잭션 처리의 특성상 InnoDB 엔진을 따라갈 수 없다. MEMORY 엔진은 테이블 수준의 잠금을 사용해서 제대로된 성능을 낼 수 없다. 또한, 가변 길이 타입의 칼럼을 지원하지 않는다. MEMORY 엔진 또한 이후에는 제거될 것으로 보인다.

***
## __4.3 MyISAM 스토리지 엔진 아키텍처__
MyISAM 스토리지 엔진은 키 캐시와 운영체제의 캐시 / 버퍼를 이용한다.

### __4.3.1 키 캐시__
MyISAM의 키 캐시는 InnoDB의 버퍼 풀과 비슷한 역할을 하며, 키 버퍼라고도 불린다. 버퍼 풀과 다르게 인덱스만을 버퍼링하고, 인덱스 쓰기 작업에 대해서만 부분적으로 버퍼링한다. 기본 값으로 할당된 캐시 공간 이외에 별도로 명명된 키 캐시 공간을 할당하여 제한된 값 이상의 키 캐시를 할 수 있다. 이렇게 추가 할당된 캐시 공간은 어떤 인덱스를 캐싱할지 알려줘야 한다.
```sql
CACHE INDEX 테이블명 IN 캐시 공간 이름;
```

### __4.3.2 운영체제의 캐시 및 버퍼__
MyISAM 의 인덱스는 키 캐시를 이용해서 빠르게 검색할 수 있지만, 데이터의 경우 I/O를 위한 어떠한 캐시나 버퍼링 기능도 없다. 운영체제에 디스크 I/O를 요청할 뿐이고 운영체제가 가진 기본적인 캐싱, 버퍼링 매커니즘에 의존하게 된다. 이 때에, 다른 애플리케이션이나 키 캐시가 메모리를 모두 사용할 경우 운영체제의 캐시 와 버퍼를 사용할 수 없게 되므로 운영체제가 사용할 메모리 여유 공간을 확보해둬야 한다.

### __4.3.3 데이터 파일과 프라이머리 키 (인덱스) 구조__
InnoDB 의 테이블은 PK에 의해 클러스터링되지만, MyISAM 의 테이블은 데이터 파일이 힙 공간처럼 활용된다. 즉, PK와는 무관하게 INSERT 순서대로 저장된다. 또한, ROWID라는 물리적인 주솟값을 가지는데, PK와 세컨더리 인덱스로 이 값을 포인터로 가진다.

ROWID 는 두 가지 방법으로 저장된다.
- 고정 길이
- 가변 길이

***
## __4.4 MySQL 로그 파일__
MySQL 서버의 로그 파일을 이용하면 깊은 내부 지식 없이도 MySQL 서버의 상태나 부하를 일으키는 원인을 쉽게 찾고 해결할 수 있다.

### __4.4.1 에러 로그 파일__
실행 도중 발생하는 에러나 경고 메시지가 출력된다. 에러 로그 파일에서 자주 보는 메시지
-  __MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지__ : 서버의 설정 파일을 변경, 데이터베이스가 비정상 종료 후 다시 시작하는 경우 에러 로그를 확인해서 설정 파일이 의도대로 적용됐는지 확인해야 한다.
- __마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지__ : InnoDB가 트랜잭션 복구 작업을 진행할 때에 간단한 메시지를 출력하는데, 복구에 실패할 경우 에러 메시지를 출력하고 서버는 종료된다.
- __쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지__ : 쿼리의 실행 도중 발생한 에러나 복제에서 문제가 될 만한 쿼리에 대한 경고 메시지.
- __비정상적으로 종료된 커넥션 메시지(Aborted connection)__ : 클라이언트에서 정상 종료하지 못하고 프로그램이 종료된 경우. 커넥션 종료 로직을 점검하여 메시지 발생 빈도를 낮출 수 있다.
- __InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지__ : 이 메시지는 상대적으로 크다. 모니터링 이후에는 에러 로그를 비활성화해서 에러 로그 파일이 너무 커지지 않도록 해야 한다.
- __MySQL의 종료 메시지__ : MySQL 이 의도치 않게 종료 혹은 재시작되는 경우에 마지막으로 종료되면서 출력한 메시지를 확인한다.

### __4.4.2 제너럴 쿼리 로그 파일__
서버에서 실행되는 쿼리의 전체 목록을 뽑아볼 때가 있는데, 이 때는 쿼리 로그를 활성화 후 쿼리 로그 파일을 검토하는 방법도 있다. 쿼리 로그 파일에는 쿼리 요청을 받는 순간 기록하므로 에러가 발생해도 로그 파일에 기록된다. 또한 쿼리 로그를 파일이 아닌 테이블로 저장할 수 있다.

### __4.4.3 슬로우 쿼리 로그__
서비스 적용 전 전체적인 쿼리 튜닝이나 서비스 운영 중에 성능 저하를 검사하거나 정기 점검을 위한 쿼리 튜닝을 한다. 후자의 경우 문제의 쿼리를 판단하기 위해 슬로우 쿼리 로그를 사용한다.

슬로우 쿼리 로그 파일에는 시스템에서 설정한 시간 이상이 소요된 쿼리가 모두 기록된다. 실제 소요된 시간이 기준이므로 정상 실행 완료된 쿼리만 기록된다. 이 슬로우 쿼리 로그 또한 파일과 테이블로 기록한다.

쿼리 로그 파일이 너무 많아서 쿼리를 하나씩 검토하기 어려울 경우 __Percona에서 개발한 Percona Toolkit의 `pt_query_digest` 스크립트__ 를 이용하여 쿼리를 정렬해서 쉽게 검토할 수 있다.

- __슬로우 쿼리 통계__ : 분석 결과의 최상단, 모든 슬로우 쿼리의 실행 시간, 잠금 대기 시간 등의 평균 및 최소/최대 값 표시
- __실행 빈도 및 누적 실행 시간순 랭킹__ : 각 쿼리별 응답 시간과 실행 횟수. `--order-by` 옵션으로 정렬 순서를 변경할 수 있다. 여기서 쿼리 문장을 정규화 후 만든 해시 값으로 Query ID 를 사용하며, 같은 모양이면 같은 ID를 가진다.
- __쿼리별 실행 횟수 및 누적 실행 시간 상세 정보__ : Query ID별 쿼리를 랭킹에 표시된 순서로 자세한 내용을 보여준다.