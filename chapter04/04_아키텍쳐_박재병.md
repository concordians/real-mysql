# __04장 아키텍쳐__

## 4.1 MySQL 엔진 아키텍쳐

### __4.1.1 MySQL 의 전체 구조__
MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.

#### __4.1.1.1 MySQL 엔진__
MySQL 엔진은 클라이언트의 접속과 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 쿼리의 실행을 최적화하는 옵티마이저로 이루어진다. 또한 표준 SQL 문법을 지원하여 이를 따르는 쿼리는 타 DBMS와 호환된다.

#### __4.1.1.2 스토리지 엔진__
MySQL 엔진은 쿼리를 수행하고, 데이터를 디스크에 저장하거나 디스크로부터 읽어오는 부분은 스토리지 엔진이 전담한다. MySQL 에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 테이블이 사용할 스토리지 엔진을 지정하여 해당 테이블의 모든 IO 작업을 지정한 스토리지 엔진이 처리할 수 있다.

#### __4.1.1.3 핸들러 API__
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을 때 스토리지 엔진에 요청하는데, 이러한 요청을 핸들러 요청이라 하고 여기서 사용하는 API를 핸들러 API라고 한다. 즉, MySQL 엔진과 스토리지 엔진은 핸들러 API 를 이용해 데이터를 주고 받는다.

### __4.1.2 MySQL 스레딩 구조__
MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드 스레드과 백그라운드 스레드로 구분한다.

#### __4.1.2.1 포그라운드 스레드__
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 클라이언트 사용자가 요청하는 쿼리를 처리한다. MySQL에서 포그라운드 스레드는 사용자가 요청한 작업을 처리하기 때문에 사용자 스레드라고도 한다.

#### __4.1.2.2 백그라운드 스레드__
MyISAM 과는 다르게 InnoDB 에서는 다음의 여러 작업을 백그라운드로 처리한다.
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- Inno DB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

### __4.1.3 메모리 할당 및 사용 구조__
MySQL 의 메모리 공간은 글로벌 영역과 로컬 영역으로 구분한다.
글로벌 영역은 MySQL 서버가 시작되면서 운영체제가 할당한다. 두 영역은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

#### __4.1.3.1 글로벌 메모리 영역__
클라이언트 스레드 수와 무관하게 하나의 영역만 할당된다. 필요에 따라 N개의 영억을 할당할 수 잇지만 스레드와는 무관하다.

대표적인 글로벌 메모리 영역
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### __4.1.3.2 로컬 메모리 영역__
클라이언트 스레드가 쿼리를 처리할 때 사용하는 영역이다. 클라이언트 메모리 영역이라고도 한다. 또한 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 세션 메모리 영역이라고도 표현한다.

대표적인 로컬 메모리 영역
- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### __4.1.4 플러그인 스토리지 엔진 모델__
MySQL은 플러그인 API를 제공해서 서버의 기능을 커스텀하게 확장하거나 완전히 새로운 기능을 구현할 수 있다.

### __4.1.5 컴포턴트__
MySQL 8.0 부터는 기존의 플러그인 아키텍쳐를 대체하는 컴포넌트 아키텍쳐를 지원한다.
컴포넌트는 다음의 플러그인의 단점을 보완했다.
- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 불가능
- MySQL 서버의 변수나 함수를 직접 호출하여 안전하지 않음
- 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

### __4.1.6 쿼리 실행 구조__
(사용자) -> SQL 요청 -> 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리실행기 - ( 스토리지 엔진 ) -> SQL 결과 (사용자)

#### __4.1.6.1 쿼리 파서__
사용자가 요청한 쿼리 문장을 MySQL이 인식할 수 있는 최소 단위인 토큰으로 분리해 트리 형태의 구조로 만드는 작업을 처리한다. 기본 문법 오류를 검출한다.

#### __4.1.6.2 전처리기__
파서가 만들어준 트리를 기반으로 쿼리에 있는 구조적인 문제를 확인한다. 테이블 이름, 칼럼 이름, 내장 함수와 같은 개체를 매핑해서 객체의 존재 여부와 접근 권한 등을 확인한다.

#### __4.1.6.3 옵티마이저__
쿼리를 가장 저렴한 비용으로 빠르게 처리할지 결정하는 역할을 수행하며, DBMS의 두뇌에 해당된다.

#### __4.1.6.4 실행 엔진__
실행 엔진과 핸들러는 손과 발에 비유할 수 있다. 실행 엔진은 옵티마이저가 만든 실행 계획대로 핸들러에게 요청하여 받은 결과를 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

#### __4.1.6.5 핸들러 (스토리지 엔진)__
MySQL 엔진의 요청에 따라 데이터를 디스크에 쓰고 읽어 오는 역할을 담당한다.

### __4.1.7 복제__
복제는 매우 중요한 역할을 담당한다.

### __4.1.8 쿼리 캐시__
MySQL 서버에서 쿼리 캐시는 빠른 응답을 요구하는 서비스에서 매우 중요한 역할을 담당 했다. 실행 결과를 메모리에 캐시하고, 동일한 실행의 경우 메모리에서 즉시 반환하여 매우 빠른 응답을 보인다. 그러나 데이터의 변경은 거의 없고 읽기만 하는 서비스는 흔치 않아서 MySQL 8.0 에서 완전히 제거되었다.

### __4.1.9 스레드 풀__
스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드의 개수를 조절하여 동시 요청이 많아져도 서버의 CPU 가 제한된 스레드 처리에 집중하도록 하여 자원 소모를 줄이는 것이 목적이다.

### __4.1.10 트랜잭션 지원 메타데이터__
테이블의 구조 정보와 스토어드 프로그램 등의 정보를 메타데이터 라고 하는데, 이를 5.7 버전까지는 파일에 저장하였다. 하지만 파일은 트랜잭션을 지원하지 않아서 메타데이터가 변경될 때 서버가 비정상 종료되면 일관되지 않은 상태로 남는 문제가 발생했다. '데이터베이스나 테이블이 깨졌다'로 표현.
이를 위해 8.0 부터는 메타데이터를 InnoDB의 테이블에 저장하도록 개선했다.

메타데이터를 트랜잭션 기반의 InnoDB 스토리지에 저장하도록 개선하여 데이터베이스가 깨지는 문제를 유발하지 않게 되었다.