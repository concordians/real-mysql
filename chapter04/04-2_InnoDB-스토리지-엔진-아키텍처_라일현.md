### 4.2 InnoDB 스토리지 엔진 아키텍처
- MySQL의 스토리지 엔진 중 가장 많이 사용되는 InnoDB 스토리지 엔진
- 유일하게 레코드 기반의 잠금을 제공 -> 높은 동시성 처리 가능 / 안정적 / 성능이 뛰어남
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/WaqpjFNQr7.png "innoDB 구조")

#### 4.2.1 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장
  (= 프라이머리 키 값의 순서대로 디스크에 저장)
- 모든 세컨더리 인덱스의 논리적인 주소는 프라이머리 키의 값 (레코드의 주소X)
- 프라이머리 키 = 클러스터링 인덱스 : 레인지 스캔을 빨리 처리할 수 있음
- MyISAM 스토리지 엔진에서는 클러스터링 키 지원X

#### 4.2.2 외래 키 지원
- 외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있음 (개발 환경에서는 좋은 가이드 역할)
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 인덱스 생성 필요, 잠금이 여러 테이블로 전파 -> 데드락 발생↑
- 외래 키 관계 체크 작업 일시 중지 : foreign_key_checks 시스템 변수를 OFF로 설정 (레코드 적재, 삭제 작업도 부가적 체크가 불필요해짐)
- foreign_key_checks를 OFF로 설정하면 외래 키 관계의 부모 테이블에 대한 작업(ON DELETE CASCADE, ON UPDATE CASCADE)도 무시함

```
// 외래 키 관계 체크 작업 일시 중지
mysql> SET foreign_key_check=OFF;
```
#### 4.2.3 MVCC(Multi Version Concurrency Control)
- 목적 : 잠금을 이용하지 않는 일관된 읽기를 제공
- InnoDB는 언두로그(Undo log)를 이용해 MVCC 기능 구현
- 멀티 버전 : 하나의 레코드에 대해 여러 개의 버전이 동시 관리됨


```
// 격리 수준이 READ_COMMITTED인 MySQL 서버
// InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는가
mysql> CREATE TABLE member (
	m_id INT NOT NULL,
	m_name VARCHAR(20) NOT NULL,
	m_area VARCHAR(100) NOT NULL,
	PRIMARY KEY (m_id),
	INDEX ix_area (m_area)
);
mysql> INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
mysql> COMMIT;
```
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/YoUWoF5fT0.png "innoDB 버퍼풀과 데이터 파일의 상태")


```
// MEMBER 테이블에 UPDATE 문장이 실행될 때 처리 절차
mysql> UPDATE member SET m_area='경기' WHERE m_id=12;
```
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/JlbtKVpA3k.png "UPDATE 후 innoDB 버퍼 풀과 데이터 파일 및 언두 영역의 변화")

- UPDATE 문자 실행되면 커밋 실행 여부와 관계없이 InnoDB 버퍼 풀은 새로운 값인 '경기'로 인서트
- InnoDB는 ACID를 보장, 일반적으로 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방


```
// 아직 COMMIT이나 ROLLBACK되지 않은 상태에서 다음 같은 쿼리로 작업 중인 레코드를 조회한다면?
// 정답 : MySQL 서버의 시스템 변수(transaction_isolation)에 설정된 격리 수준에 따라 다름
mysql> SELECT * FROM member WHERE m_id=12;
```
- 격리 수준이 READ_UNCOMMITED인 경우에는 InnoDB 버퍼 풀이 현재 테이블이 가진 변경된 데이터를 읽어서 반환
- READ_COMMITED이나 그 이상의 격리수준(REPEATABLE_READ, SERIALIZABLEE)인 경우 변경 이전의 데이터를 보관한 언두 영역의 데이터를 반환

#### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행
- InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않음
- 격리 수준이 SERIALIZABLE이 아니면 순수한 읽기는 항상 잠금을 대기하지 않고 바로 실행
- 잠금 없는 일관된 읽기 : 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않음
- 일관된 읽기를 위한 언두 로그를 삭제하지 못하고 계속 유지하면 -> 오랜 시간 활성 상태인 트랜잭션으로 남고 -> MySQL 서버가 느려지거나 문제 발생 가능성 있음
- 트랜잭션이 시작됐다면 가능한 빨리 롤백, 커밋을 통해 트랜잭션 완료를 하는 것이 좋음

![](https://i.esdrop.com/d/f/5BqG1Oh0zF/jirYRkKnA2.png "변경 중인(COMMIT 전) 레코드 읽기")

#### 4.2.5 자동 데드락 감지
- 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 목록을 그래프(Wait-for List)형태로 관리
- InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있음 -> 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사, 교착 상태에 빠진 트랜잭션을 찾아 그중 하나를 강제 종료
	-> 어떤 트랜잭션을 먼저 종료할 것인가? : 언두 로그의 양이 기준, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백 대상
	-> 롤백을 해도 언두 처리를 해야 할 내용이 적고, 트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하를 덜 유발해서
- 상위 레잉어인 MySQL엔진에서 관리되는 테이블 잠금(LOCK_TABLES명령으로 잠긴 테이블)은 볼 수 없어서 데드락 감지가 불확실할 수 있음
	-> innodb_table_locks 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부 레코드 잠금, 테이블 레벨의 잠금까지 감지
- innodb_deadlock_detect 시스템 변수 : OFF로 설정시 데드락 감지 스레드 작동X
- innodb_lock_wait_timeout 활성화 : 데드락 상황에서 일정 시간이 지나면 자동으로 요청 실패 후 에러메시지 반환

#### 4.2.6 자동화된 장애 복구
- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행
- 자동 복구로 해결되지 않으면 복구를 멈추고 MySQL 서버는 종료됨
- innodb_force_recovery : MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 함
	1. innoDB 로그 파일이 손상됐다면 6으로 설정 후 MySQL 서버 재기동
	2. innoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 MySQL 서버 기동
	3. 어떤 문제인지 알 수 없다면 설정값을 1부터 6까지 변경 후 재기동
- 일단 서버가 기동되고 InnoDB 테이블이 인식되면 mysqldump를 이용해 데이터를 가능한 만큼 백업, 그 데이터로 MySQL 서버의 DB와 테이블 재생성하는것이 좋음
- innodb_force_recovery
	- 1(SRV_FORCE_IGNORE_CORRUPT)
		innoDB 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 MySQL 서버를 시작함
		에러 로그 파일에 Database page corruption on disk or a failed 메시지 출력될 때 유력
		-> 서버가 시작되면 mysqldump 프로그램, SELECT INTO OUTFILE... 명령을 이용해 덤프, 데이터베이스를 다시 구축하는게 좋음
	- 2(SRV_FORCE_NO_BACKGROUND)
		백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 MySQL 서버를 시작
		(innoDB는 쿼리의 처리를 위해 여러 종류의 백그라운드 스레드를 동시에 사용함)
		InnoDB의 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생한다면 이 모드로 복구
	- 3(SRV_FORCE_NO_TRX_UNDO)
		커밋되지 않은 트랜잭션의 작업을 롤백하지 않고 그대로 둠
		-> 1처럼 서버가 시작되면 mysqldump 프로그램, SELECT INTO OUTFILE... 명령을 이용해 덤프, 데이터베이스를 다시 구축하는게 좋음
	- 4(SRV_FORCE_NO_MERGE)
		인서트 버퍼의 손상을 감지 시 4로 설정하면 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL이 시작되게 함
		innoDB는 INSERT, UPDAET, DELETE 등의 데잍 ㅓ변경으로 인한 인덱스 변경 작업을 상황에 따라 즉시 처리할 수도 있고 인서트 버퍼에 저장 후 나중에 처리도 가능
		-> 인서트 버퍼는 실제 데이터와 관련된 부분이 아니고 인덱스 관련 부분이므로 테이블을 덤프한 후 다시 데이터베이스를 구축하면 데이터의 손실없이 복구 가능
	- 5(SRV_FORCE_NO_UNDO_LOG_SCAN)
		innoDB 엔진이 언두 로그를 모두 무시하고 MySQL을 시작 가능
		이 모드로 복구되면 MySQL 서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리됨
		이 때도 mysqldump를 이용해 데이터를 백업하고 데이터베이스를 새로 구축해야 함
	- 6(SRV_FORCE_NO_LOG_REDO)
		리두 로그를 모두 무시한 채로 MySQL 서버 시작
		리두 로그가 손상되면 MySQL 서버가 시작되지 못함
		커밋됐더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이트는 모두 무시됨
		기존 리두 로그는 모두 삭제하고 MySQL 서버를 재시작 (MySQL 서버가 재시작하면서 리두 로그 생성하므로 별도의 파일을 만들 필요는 없음)
		이 때도 mysqldump를 이용해 데이터를 백업하고 데이터베이스를 새로 구축해야 함

- 6가지 방법으로도 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법뿐임
- 마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 InnoDB의 복구를 이용하는 것보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 더 적을 수 있음

#### 4.2.7 InnoDB 버퍼 풀
- 버퍼 풀 : 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
			쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 함
- INSERT, UPDATE, DELETE 처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하므로 랜덤한 디스크 작업 발생 -> 이를 모아서 처리하고 랜덤한 디스크 작업의 횟수를 줄여주는게 버퍼 풀

##### 4.2.7.1 버퍼 풀의 크기 설정
- 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해서 설정
- 레코드 버퍼 : 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간
- 커넥션이 많고 사용하는 테이블이 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 많이 필요해질 수 있음
- MySQL가 사용할 레코드 버퍼 공간은 별도 설정이 불가능 -> 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라 결정됨
- 5.7버전부터 버퍼 풀 크기를 동적으로 조절 가능하도록 개선됨
- InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정 후 조금씩 증가시키는 방법이 최적
- 버퍼 풀 크기를 처음 설정한다면 권장하는 방법
	1. 운영체제 전체 메모리 공간이 8GB 미만이면 50% 정도만 InnoDB 버퍼 풀로 설정 후 나머지 메모리 공간은 MySQL 서버와 운영체제, 다른 프로그램의 공간으로 확보해주는 것이 좋음
	2. 전체 메모리 공간이 8GB 이상이면 InnoDB  버퍼 풀 크기를 전체 메모리의 50%로 시작해서 조금씩 올려가면서 최적점을 찾음
	3. 운영체제의 전체 메모리 공간이 50GB 이상이면 대략 15-30GB 정도를 운영체제와 다른 응용 프로그램을 위해서 남겨두고 나머지는 InnoDB 버퍼 풀로 할당
- innodb_buffer_pool_size 시스템 변수 : InnoDB 버퍼 풀의 크기 설정, 동적으로 버퍼 풀의 크기 확장 가능
- 버퍼 풀의 크기를 줄이거나 늘릴 때는 128MB 단위로 처리됨
- InnoDB의 버퍼 풀 전체를 관리하는 잠금(세마포어)로 인한 내부 장금 경합 문제 : 버퍼 풀을 여러 개로 쪼개어 관리해서 개선
- innodb_buffer_pool_instances 시스템 변수 : 버퍼 풀을 여러 개로 분리해서 관리 (각 버퍼 풀은 버퍼 풀 인스턴스라고 표현)
- 기본적으로 버퍼 풀 인스턴스 개수는 8개로 초기화 (버퍼 풀을 위한 메모리 크기가 1GB 미만이면 버퍼풀 인스턴스는 1개만 생성, 40GB 이하 수준이면 8유지)

##### 4.2.7.2 버퍼 풀의 구조
- 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기(innodb_page_size시스템 변수에 설정된)의 조각을 ㅗ쪼개어 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장
- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 3개의 자료구조를 관리
	1. LRU(Least Recently Used) 리스트
		목적 : 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화
		LRU와 MRU(Most Recently Used) 리스트가 결합된 형태
		LRU : Old 서브 리스트 / MRU : New 서브리스트
		데이터를 찾는 과정
			1) 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
			2) 디스크에서 필욯나 데이터 페이지를 버퍼 풀에 적재, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
			3) 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
			4) 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 나이가 오래된 페이지는 버퍼 풀에서 제거 됨
			5) 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
	2. 플러시(Flush) 리스트
		디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 편경 시점 기준의 페이지 목록을 관리
		리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 항상 보장하지는 않음
	3. 프리(Free) 리스트 
		InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
		사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용
![](https://i.esdrop.com/d/f/5BqG1Oh0zF/eCuwfM2rdR.png "버퍼 풀 관리를 위한 LRU 리스트 구조")

##### 4.2.7.3 버퍼 풀과 리두 로그
- 버퍼 풀 설정↑ -> 쿼리 성능↑
- 버퍼 풀은 캐시와 쓰기 버퍼링으로 서버 성능 향상
- 리두 로그 : 재사용 불가능한 공간
- 체크포인트 에이지 : 활성 리두 공간의 크기
1. InnoDB 버퍼 풀은 100GB이며 리두 로그 파일의 전체 크기는 100MB인 경우
	리두 로그 파일 크기 : 100MB -> 체크포인트 에이지 : 100MB만 허용
	평균 리두 로그 엔트리가 4KB라면 25600개 정도의 더티페이지만 버퍼 풀에 보관 가능
2. InnoDB 버퍼 풀은 100MB이며 리두 로그 파일의 전체 크기는 100GB인 경우
	400GB 정도의 더티페이지를 가질 수 있음
	하지만 버퍼 풀의 크기가 100MB이므로 최대 허용 가능한 더티 페이지는 100MB
	
##### 4.2.7.4 버퍼 풀 플러시(Buffer Pool Flush)
- 아직 디스크로 기록되지 않은 더티 페이지들을 성능상 악영향 없이 디스크에 동기화 하기 위한 백그라운드 플러시 기능
	1. 플러시 리스트(Flush_list) 플러시
		플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업 수행
		제공하는 시스템 변수들
			1. innodb_page_cleaners
				클리너 스레드의 개수 조정
				innodb_page_cleaners > 버퍼 풀 인스턴스 개수 인 경우 innodb_buffer_pool_instances 설정값으로 자동 변경 (가능한 동일하게 설정해주는게 좋음)
			2. innodb_max_dirty_pages_pct
				더티 페이지 비율 조정 (전체 버퍼 풀이 가진 페이지의 90% 이상인 경우 조정 대상)
				가능한 기본값을 유지하면 좋음
			3. innodb_max_dirty_pages_pct_lwm
				일정 수준 이상의 더티 페이지 발생 시 보금씩 더티 페이지를 디스크로 기록 
				더티 페이지 多 -> 디스크 쓰기 폭발(Disk IO Burst) 현상 발생 가능성↑
			4. innodb_io_capacity
				디스크가 적절히 처리할 수 있는 수준의 값을 설정
			5. innodb_io_capacity_max
				디스크가 최대 성능을 발휘할 때 어느 정도의 디스크 읽고 쓰기가 가능한지 설정
			6. innodb_adaptive_flushing
				리두 로그 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행
				InnoDB는 어댑티브 플러시라는 기능으로 해당 시스템 변수를 조정
			7. innodb_flush_neighbors
				더티 페이지를 디스크에 기록할 때 디스크에서 근접한 페에지 중에서 더티 페이지가 있다면 함께 묶어서 디스크로 기록하게 해주는 기능을 활성화할지 결정
				데이터 저장이 HDD라면 1,2로 설정 / SSD라면 비활성 모드 권장
	2. LRU 리스트(LRU_list) 플러시
		LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들 때 해당 함수 사용
		innodb_lru_scan_depth 시스템 변수 설정된 개수만큼 페이지 스캔 -> innodb 스토리지 엔진이 스캔 후 더티 페이지는 디스크 동기화
	
##### 4.2.7.5 버퍼 풀 상태 백업 및 복구
- innodb_buffer_pool_dump_now : 시스템 변수로 버퍼 풀의 상태를 백업 가능
- innodb_buffer_pool_load_now : 서버 재시작 후 백업된 버퍼 풀의 상태 복구
- innodb_buffer_pool_load_abort : 버퍼 풀 적재 작업 중지

```
// MySQL 서버 셧다운 전 버퍼 풀의 상태 백업
mysql> SET GLOBAL innodb_buffer_pool_dump_now=ON;

// MySQL 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
mysql> SET GLOBAL innodb_buffer_pool_load_now=ON;

// 버퍼 풀 복구 과정이 어느정도 진행됐는지 확인
mysql> SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'G

// 버퍼 풀 복구 중지
mysql> SET GLOBAL Innodb_buffer_pool_load_abort=ON;
```
- 버퍼 풀의 백업은 데이터 디렉터리에 ib_buffer_pool이라는 이름으로 생성
- 백업 파일은 버퍼 풀이 커도 보통 몇십 MB 이하인데 이는 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장하기 때문
- 버퍼 풀의 백업과 복구 자동화를 위해서는 innodb_buffer_pool_dump_at_shutdown, innodb_buffer_pool_load_at_startup 설정을 MySQL 서버 설정 파일에 추가

##### 4.2.7.6 버퍼 풀의 적재 내용 확인
- innodb_cached_indexes 테이블 : 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인 가능
- 테이블 인덱스별로 페이지가 InnoDB 버퍼 풀에 적재된 비율은 확인 불가

#### 4.2.8 Double Write Buffer
- 페이지가 일부만 기록되는 파셜 페이지, 톤 페이지 현상을 방지하기 위한 기법
- 데이터의 안정성을 위해 활용
- A~E까지 더티 페이지를 디스크로 플러시하는 과정
	1. 더티 페이지를 하나로 묶고 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록
	2. InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기 실행
- innodb_doublewrite : DoubleWrite 기능 사용 여부

![](https://i.esdrop.com/d/f/5BqG1Oh0zF/fwD6SGsFAh.png "Double Write 작동 방식")
