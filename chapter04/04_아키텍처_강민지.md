# 4장 아키텍처

# 

- MySQL 엔진 : 머리
- 스토리지 엔진 : 손발
    - > 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용할 수 있다.

4.1 MySQL 엔진아키텍처

4.1.1 MySQL의 전체 구조

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2037a9a015173f4cd3bacb2d7f8f5378b4/Untitled.png)

- MySQL은 일반 상용 RDBMS와 같이 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원한다.
- MySQL 엔진 : 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다. MySQL은 표준 SQL(ANSI SQL)문법을 지원하기 때문에표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다.
    - > 요청된 SQL문장을 분석하거나 최적화 하는 등 DBMS의 두뇌에 해당하는 처리를 수행.
- 스토리지 엔진
    - > 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담한다.
    - MySQL서버에서 MySQL엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
- 핸들러 API
    - > MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를요청하는데, 이러한 요청을 핸들러요청이라 하고, 여기서 사용되는 API를핸들러 API라고 한다.

4.1.2 MySQL 스레딩 구조

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2037a9a015173f4cd3bacb2d7f8f5378b4/Untitled%201.png)

- MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드(Foreground) 스레드와 백그라운드(Background)스레드로 구분할 수 있다.
- 포그라운드 스레드 (클라이언트 스레드) : 최소한 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아간다.
- 백그라운드 스레드 : MyISAM의 경우에는 별로 해당 사항이 없는 부분이지만 InnoDB는 다음과 같이 여러가지 작업이 백그라운드로 처리된다. 그 중 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을처리하는 쓰기 스레드일 것이다.

4.1.3 메모리 할당 및 사용 구조

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2037a9a015173f4cd3bacb2d7f8f5378b4/Untitled%202.png)

- 글로벌 메모리 영역 : 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다. 단, 필요에따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와는 무관하며, 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유된다.
- 로컬 메모리 영역 : 세션 메모리 영역이라고도 표현하며, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를처리하는데 사용하는 메모리 영역이다.
- 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다. 또한가지 중요한 특징은 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다는 점이다. 대표적으로 소트 버퍼나 조인 버퍼와 같은 공간이 그러하다. (쿼리를 실행하는 순간에만 할당했다가 해제)

4.1.4 플러그인 스토리지 엔진 모델

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2037a9a015173f4cd3bacb2d7f8f5378b4/Untitled%203.png)

4.1.5 컴포넌트

- MySQL서버의 플러그인은 다음과 같은 몇가지 단점이 있는데 컴포넌트는 이러한 단점들을 보완해서 구현됐다.
    - 플러그인은 오직 서버와 인터페이스 할 수 있고, 플러그인끼리는 통신할 수 없음
    - 플러그인은 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화안됨)
    - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
- 5.7버전까지는 비밀번호 검증 기능이 플러그인 형태로 제공됐지만 8.0의 비밀번호 검증 기능은 컴포넌트로 개선됐다.

4.1.6 쿼리 실행 구조

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2037a9a015173f4cd3bacb2d7f8f5378b4/Untitled%204.png)

1)쿼리파서 : 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호) 으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미한다.

2)전처리기 : 파서과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지확인한다.

3)옵티마이저 : 사용자의 요청으로 들어온 쿼리문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당하며, DBMS의 두뇌에 해당한다고 볼 수 있다.

4)실행엔진 : 옵티마이저가 두뇌라면 실행엔진과 핸들러는 손과 발에 비유할 수 있다. (옵티마이저는 회사의 경영진, 실행 엔진은 중간관리자, 핸들러는 각 업무의 실무자로 비유할 수 있다.)

5)핸들러(스토리지 엔진):서버의 가장 밑단에서 실행 엔진의 요처에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당한다.

4.1.7 복제 : 별도 장에서 추가로 다룰 예정

4.1.8 쿼리 캐시 : 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할을 담당.

실제 쿼리 캐시 기능이 큰 도움이 됐던 서비스는 거의 없었다. 오히려 수많은 버그의 원인으로 지목되는 경우가 많았음. 이같은 이유로 서버에서 쿼리 캐시를 제거한 것은 매우 좋은 선택.

4.1.9 스레드 풀 : 커뮤니티에디션은 지원하지 않고, 엔터프라이즈에디션만 기능을 제공, 여기서는 엔터프라이즈 에디션에 포함된 스레드 풀 대신 Percona Servef에서 제공하는 스레드 풀 기능을 살펴보고자 한다.

- 플러그인 형태로 작동하게 구현되어있음 (플러그인 라이브러리 파일은 서버에 설치(명령어사용)후 사용
- 스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게해서 서버의 사원소모를 줄이는 것이 목적이다. 많은사람들이 그냥 스레드풀만 설치하면 성능이 두배쯤 올라갈 거라고 기대하는데, 스레드 풀이 실제 서비스에서 눈에띄는 성능 향상을 보여준 경우는 드물었다