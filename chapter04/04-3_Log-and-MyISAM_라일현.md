## 4.3 MyISAM 스토리지 엔진 아키텍처

![](https://i.esdrop.com/d/f/5BqG1Oh0zF/wSBIrlQuPc.png "MyISAM 스토리지 엔진 구조")


### 4.3.1 키 캐시
- InnoDB의 버퍼 풀과 비슷한 역할
- 인덱스만을 대상으로 동작 (인덱스 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할)
- 키 캐시 히트율 = 100 - (Key_reads / Key_read_requests * 100) -> 키 캐시가 얼마나 효율적으로 작동하는가
- Key_reads : 인덱스를 디스크에서 읽어 들인 횟수 / Key_read_requests : 키 캐시로부터 인덱스를 읽은 횟수
- 일반적으로 키 캐시 히트율을 99% 이상으로 유지하는 것을 권장
- key_buffer_size : 키 캐시 공간 설정 파라미터

```
// 상태값을 알아보기 위한 명령
mysql> SHOW GLOBAL STATUS LIKE 'Key%';

// 기본 키 캐시 4GB와 kbuf_board, kbuf_comment라는 키 캐시가 각각 생성됨
// 기본 키 이외에 kbuf_board, kbuf_comment와 같이 따로 명명된 키 캐시는 아무런 설정을 하지 않으면 메모리를 해당만하고 사용하지 않게 됨
key_buffer_size = 4GB
kbuf_board.key_buffer_size = 2GB
kbuf_comment.key_buffer_size = 2GB

// 따라서 아래와 같이 새로 명명한 키 캐시는 어떤 인덱스를 캐시할지 MyISAM 스토리지 엔진에 알려줘야 한다
mysql> CACHE INDEX db1.board, db2.board IN kbuf_board;
mysql> CACHE INDEX db1.comment, db2.comment IN kbuf_comment;
```

### 4.3.2 운영체제의 캐시 및 버퍼
- MyISAM 테이블의 **인덱스**는 키 캐시를 이용해 디스크 검색 없이 빠른 검색이 가능
- MyISAM 테이블의 **데이터**는 디스크의 I/O문제를 해결해 줄 캐시, 버퍼링 기능이 MyISAM 스토리지 엔진에는 없음
	- 따라서 MyISAM 테이블의 데이터는 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청됨
	- 운영체제에서는 디스크로부터 읽고 쓰는 파일에 대한 캐시나 버퍼링 매커니즘을 탑재해서 매번 디스크의 파일을 읽진 않음
- 운영체제 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙
- 전체 메모리가 모두 사용중이라면 MyISAM 테이블은 데이터를 캐시하지 못함
	- 문제 방지를 위해 데이터베이스에서 MyISAM 테이블을 주로 사용한다면 운영체제가 사용할 수 있는 캐시 공간을 위해 충분한 메모리를 비워둬야 함

### 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조
- InnoDB 스토리지 엔진을 사용하는 테이블은 프라이머리 키에 의해 클러스터링되어 저장됨
- MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 힙 공간처럼 활용됨
	- 레코드는 프라이머리 키 값과 무관하게 INSERT되는 순서대로 데이터 파일에 저장
	- MyISAM 테이블에 저장되는 레코드는 모두 ROWID라는 물리적인 주솟값을 가짐
	- 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가짐
- MyISAM 테이블에서 ROWID는 **가변 길이**와 **고정 길이** 두 가지 방법으로 저장됨
	- 고정 길이 ROWID
		자주 사용되지 않음
		MyISAM 테이블을 생성할 때 MAX_ROWS 옵션을 명시해서 테이블이 최대로 가질 수 있는 레코드가 한정되면 ROWID 값으로 **4바이트 정수**를 사용함
		**ROWID = 레코드가 INSERT된 순번**
	- 가변 길이 ROWID
		MyISAM 테이블을 생성할 때 MAX_ROWS 옵션을 명시하지 않으면 ROWID는 최대 **myisam_data_pointer_size 시스템 변수에 설정된 바이트 수만큼** 공간 사용이 가능
		myisam_data_pointer_size 기본 값은 7이며 2바이트부터 7바이트까지 가변적인 ROWID를 가지게 됨
		ROWID 저장 용도(첫 번째 바이트) + 실제 ROWID 저장(나머지 바이트)
		**ROWID = 레코드의 위치**
		
## 4.4 MySQL 로그 파일

### 4.4.1 에러 로그 파일
- MySQL 실행되는 도중에 발생한 에러나 경고 메시지가 출력되는 로그 파일
- 파일의 위치 : MySQL 설정 파일(my.cnf)에서 log_error라는 이름의 파라미터로 정의된 경로에 생성
	- 별도의 정의가 없다면 데이터 디렉터리(datadir 파라미터에 설정된 디렉터리)에 .err라는 확장자가 붙은 파일로 생성

1. 4.4.1.1 MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
	- 확인이 필요한 경우 : 설정 파일 변경, 데이터베이스 비정상 종료 후 재시작
	- 설정된 변수의 이름, 값의 적용 확인이 필요
	- mysqld: ready for connections : MySQL 서버가 정상적으로 기동됨
	- 특정 변수가 무시된 경우 MySQL 서버는 정상적으로 기동하지만 해당 파라미터는 MySQL에 적용되지 못한 것을 의미
	- 시작되지 못하는 경우 : 변수명을 인식하지 못함, 설정된 파라미터 값을 인식하지 못함

2. 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
	- InnoDB의 경우에 MySQL 서버가 비정상 혹은 강제 종료됐다면 다시 시작되면서 완료되지 못한 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터를 다시 기록하는 재처리 작업을 수행함
	- 재처리 작업에 실패하면 해당 에러메시지를 출력하고 이 단계에서 발생하는 문제는 해결하기 어려운 경우가 많음
	- 때로는 innodb_force_recovery 파라미터를 0보다 큰 값으로 설정하고 재시작하면 MySQL이 시작될 수 있음

3. 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
	- 에러 로그 파일 검토를 통해 발견 가능하며 사전 예방이 어려움
	- 쿼리 실행 도중 발생한 에러, 복제에서 문제가 될 만한 쿼리에 대한 경고메시지가 기록됨

4. 비정상적으로 종료된 커넥션 메시지(Aborted connection)
	- 클라이언트 애플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우 MySQL 서버의 에러 로그 파일에 Aborted connection 내용이 기록됨
	- 중간에 네트워크에 문제가 있어 끊어지는 경우도 해당 메시지가 기록됨
	- 해당 메시지가 많이 기록된다면 커넥션 종료 로직을 검토할 필요가 있음
	- max_connect_errors 시스템 변숫값이 낮게 설정된 경우 : 클라이언트 프로그램이 MySQL 서버에 접속하지 못하고 Host 'host_name'is blocked 에러 발생
	
5. InnoDB의 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS 같은)의 결과 메시지
	- InnoDB의 테이블 모니터링, 락 모니터링, InnoDB의 엔진 상태를 조회하는 등의 명령은 상대적으로 큰 메시지를 에러 로그 파일에 기록
	- 이러한 모니터링 기능은 사용 후 비활성화해야 파일 시스템의 공간을 낭비하지 않을 수 있다

6. MySQL의 종료 메시지
	- 가끔 MySQL 서버가 이유 모르게 종료되거나 재시작 되는 경우 서버 종료시 출력된 메시지를 확인해야 함
	- Received SHUTDOWN from user... : 어떤 사용자가 서버를 종료시킴
	- 종료 관련 메시지가 없거나 스택 트레이스(16진수 주솟값이 출력되는 등) : 서버가 세그먼테이션 폴트로 비정상적으로 종료됨
	- 세그먼테이션 폴트로 종료된 경우 스택 트레이스 내용을 최대한 참조해서 MySQL 버그 원인을 찾고 MySQL 버전 업그레이드, 회피책을 찾는 것이 최적의 방법
	
### 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)
- 서버에서 실행되는 쿼리 전체 목록 검토 방법 : 쿼리 로그 활성화 > 쿼리를 쿼리 로그 파일로 기록 > 해당 파일 검토
- 쿼리 로그 파일은 시간 단위로 실행됐던 쿼리 내용이 모두 기록됨
- 제너럴 쿼리 로그 : 실행되기 전에 쿼리 요청을 받으면 바로 기록함 > 쿼리 실행 중에 에러가 발생해도 로그 파일에 기록됨
- 쿼리 로그 파일 위치 : general_log_file 파라미터에 설정, 테이블에 저장되도록 설정되었다면 파일이 아닌 SQL로 조회해서 검토 (general_log, slow log 테이블)
- log_output 파라미터: 쿼리 로그를 파일/테이블로 저장할지 결정 
```
mysql> SHOW GLOBAL VARIABLES LIKE 'general_log_file';
```

### 4.4.3 슬로우 쿼리 로그
- 정상 수행됐으며 실행하는 데 걸린 시간이 long_query_time에 정의된 시간보다 많이 걸린 쿼리
- MySQL 서버의 쿼리 튜닝
	- 서비스가 적용되기 전에 전체적으로 튜닝 (모든 대상 쿼리를 튜닝해서 해결)
	- 서비스 운영중에 MySQL 서버의 전체적인 성능 저하를 검사, 정기적인 점검을 위한 튜닝 (슬로우 쿼리 로그등을 참고해서 판단 후 튜닝)
- long_query_time : 설정된 시간이 소요된 쿼리가 모두 기록됨 (초단위로 설정하지만 소수점 값으로 마이크로 초 단위 설정이 가능)
- log_output 파라미터: 쿼리 로그를 파일/테이블로 저장할지 결정
	- TABLE 옵션으로 설정하더라도 CSV 스토리지 엔진을 사용하므로 CSV 파일로 저장하는 것과 동일하게 작동
- MySQL의 잠금 처리
	- MySQL 엔진 레벨
	- 스토리지 엔진 레벨
- 정상적으로 실행완료된 쿼리만 기록될 수 있음
- Time : 쿼리가 종료된 시점
- User@Host : 쿼리를 실행한 사용자 계정
- Query_time : 쿼리가 실행되는 데 걸린 전체 시간
- Lock_time : MySQL 엔진 레벨에서 관장하는 테이블 잠금에 대한 대기 시간, 잠금 체크와 같은 코드 실행 부분 시간까지 포함 (해당 값이 0이 아니더라도 무조건 잠금 대기가 있었다고 판단할 수 없음)
- Rows_examined : 쿼리가 처리되기 위해 몇 건의 레코드에 접근했는지를 의미
- Rows_sent : 실제 몇 건의 처리 결과를 클라이언트로 보냈는지
-> Rows_examined은 높은데 Rows_sent 건수가 상당히 적다면 튜닝할 가치가 있음
- MyISAM, MEMORY 스토리지 엔진에서는 테이블 단위의 잠금을 사용하고 MVCC 같은 메커니즘이 없어 SELECT라도 Lock_time이 1초 이상 소요될 수 있음
- 쿼리 로그가 많아 튜닝할 대상을 식별하기 어려울 땐 Percona사의 Percona Toolit의 pt-query-digest 스크립트를 이용하면 빈도, 처리 성능별로 쿼리를 정렬해서 볼 수 있음

```
// Slow Log 파일 분석
linux> pt_query_digest --type='slowlog' mysql-slow.log > parsed_mysql-slog.log
```

#### 4.4.3.1 슬로우 쿼리 통계
- 모든 쿼리를 대상으로 슬로우 쿼리 로그의 실행 시간(Exec time), 잠금 대기 시간(Lock time) 등에 대해 평균 및 최소/최대 값을 표시

#### 4.4.3.2 실행 빈도 및 누적 실행 시간순 랭킹
- 각 쿼리별로 응답 시간, 실행 횟수를 보여줌
- pt-query-digest 명령 실행 시 --order-by 옵션으로 정렬 순서 변경 가능
- 같은 모양의 쿼리는 동일 Query ID를 가짐 (Query ID는 실행된 쿼리 문장을 정규화(쿼리에 사용된 리터럴 제거)해서 만들어진 해시 값)

#### 4.4.3.3 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보
- Query ID별 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 보여줌
