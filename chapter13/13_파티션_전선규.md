# 13. 파티션

> [13.1 개요](#13.1-개요)
>
> - [13.1.1 파티션을 사용하는 이유](#13.1.1-파티션을-사용하는-이유)
>   - 단일 insert와 단일 또는 범위 select의 빠른 처리
>   - 데이터의 물리적인 저장소를 분리
>   - 이력 데이터의 효율적인 관리
> - [13.1.2 MySQL 파티션의 내부 처리](#13.1.2-MySQL-파티션의-내부-처리)
>
> [13.2 주의사항](#13.2-주의사항)

<br>

## 13.1 개요

### 13.1.1 파티션을 사용하는 이유

- 테이블 데이터가 많아진다고 무조건 파티션을 적용하는 것이 효율적이진 않음
- 효율적일 경우
  - 하나의 테이블이 너무 커서 인덱스의 크기가 물리 메모리보다 훨씬 클 때
  - 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등

##### 단일 insert와 단일 또는 범위 select의 빠른 처리

- 인덱스는 일반적으로 select을 위한 것으로 보이지만 update / delete 쿼리를 위해 필요할 때도 많음

  - update, delete cㅓ리를 위해 대상 레코드를 검색하려면 인덱스가 필수적
  - 레코드 변경 시 인덱스 변경을 위한 부가적 작업 발생
  - 인덱스가 커질수록 select, insert, update, delete 작업도 함께 느려짐

- 한 테이블의 인덱스 크기가 물리적으로 MySQL이 사용 가능한 메모리 공간보다 크다면 영향이 더 심각

  - 데이터는 물리 메모리보다 큰 것이 일반적이지만, 인덱스의 Working Set이 실질적인 물리 메모리보다 크다면 쿼리 처리가 상당히 느려짐

  - 아래 그림처럼 데이터와 인덱스를 조각화하여 물리 메모리를 효율적으로 사용할 수 있게 함

    - 예를 들어 데이터가 10GB, 인덱스가 3GB

    - 대부분의 테이블은 13GB 전체를 항상 사용하지 않고 일정 부분만 활발하게 사용함

      (게시물이 100만 건이라도 최신 20~30% 게시물이 활발하게 조회될 것)

    - 활발하게 사용되는 데이터를 'Working Set'이라고 표현함

    <img src="./images/13-1.png" alt="drawing" width="80%" align="left" />

    <br>

    <img src="./images/13-2.png" alt="drawing" width="80%" align="left" />

    <br>

<br>

##### 데이터의 물리적인 저장소를 분리

- 데이터, 인덱스 파일이 파일시스템에서 차지하는 공간이 크다면 백업, 관리 작업도 어려워짐

  (데이터, 인덱스를 파일 단위로 관리하는 MySQL에서는 더 치명적일 수도)

- 파티션을 통해 파일의 크기를 조절하거나 파티션별 파일들이 저장될 위치와 디스크를 구분해서 저장해 해결할 수도 있음

- (MySQL은 테이블의 파티션 단위로 인덱스를 생성하거나 파티션별로 다른 인덱스를 가지는 형태는 미지원)

<br>

##### 이력 데이터의 효율적인 관리

- 로그 데이터

  - 단기간에 대량으로 누적되고 일정 기간 지나면 쓸모가 없어짐
  - 시간이 지나면 별도로 아카이빙하거나 백업한 후 삭제하는 것이 일반적
  - 다른 데이터에 비해 라이프 사이클이 상당히 짧음

- 불필요해진 로그 데이터를 백업하거나 삭제하는 작업은 일반 테이블에서 상당히 고부하의 작업에 속함

- 파티션 테이블로 효율적 관리 가능

  - 불필요 데이터 삭제 작업은 단순히 파티션을 추가/삭제 함으로써 간단하고 빠르게 해결 가능

    <img src="./images/13-3.png" alt="drawing" width="80%" align="left" />

<br>

### 13.1.2 MySQL 파티션의 내부 처리

```sql
CREATE TABLE tb_article (
  article_id INT NOT NULL,
  reg_date DATETIME NOT NULL,
  ...
  PRIMARY KEY(article_id, reg_date)
) PARTITION BY RANGE ( YEAR(reg_date) ) (
    PARTITION p2009 VALUES LESS THAN (2010),
    PARTITION p2010 VALUES LESS THAN (2011),
    PARTITION p2011 VALUES LESS THAN (2012),
    PARTITION p9999 VALUES LESS THAN MAXVALUE,
);
```

<br>

##### INSERT

- insert 되는 컬럼의 값 중에서 파티션 키인 reg_date 컬럼의 값을 이용해 파티션 표현식을 평가
- 그 결과를 이용해 레코드가 저장될 적절한 파티션을 결정
- 이후에는 일반 테이블과 동일하게 처리

<br>

<img src="./images/13-4.png" alt="drawing" width="80%" align="left" />

<br>

##### UPDATE

- 변경 대상 레코드가 어느 파티션에 저장되어 있는지 찾아야 함
- where 조건에 파티션 키 컬럼 존재
  - 파티션 키를 이용해 해당 파티션에서 빠르게 대상 레코드 검색 가능
- where 조건에 파티션 키 컬럼 미존재
  - 테이블 모든 파티션을 검색해야 함
  - 실제 레코드 변경하는 작업의 절차는 update 쿼리가 어떤 컬럼의 값을 변경하느냐에 따라 큰 차이가 생김
- update 컬럼에 따른 분류
  - 파티션 키 이외의 컬럼 변경 시 일반 테이블과 마찬가지로 컬럼 값만 변경
  - 파티션 키 컬럼이 변경될 시 기존의 레코드가 저장된 파티션에서 해당 레코드 삭제 -> 변경되는 파티션 키 컬럼 표현식 평가 -> 새로운 파티션 정해서 새로 저장

<br>

<img src="./images/13-5.png" alt="drawing" width="80%" align="left" />

<br>

##### SELECT

- 성능에 영향을 미치는 조건
  - where 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
  - where 절의 조건이 인덱스를 효율적으로 사용(index range scan)할 수 있는가?
- 4가지 경우의 수(3,4번 방법은 가급적 피해야 함)
  - 파티션 선택 가능 + 인덱스 효율적 사용 가능
    - 가장 효율적으로 처리됨
    - 파티션 갯수와 상관 없이 검색을 위해 꼭 필요한 파티션의 인덱스만 range scan
  - 파티션 선택 불가 + 인덱스 효율적 사용 가능
    - 모든 파티션 대상으로 검색해야 함
    - 각 파티션에 대해서 index range scan 가능
    - 파티션 갯수만큼 index range scan 후에 결과 병합
  - 파티션 선택 가능 + 인덱스 효율적 사용 불가
    - 해당 파티션에 대해 full table scan
    - 각 파티션 레코드가 많다면 느리게 처리
  - 파티션 선택 불가 + 인덱스 효율적 사용 불가
    - 모든 파티션에 대해 full table scan

<br>

##### 인덱스 스캔과 정렬

- local index vs global index

  - local index는 파티션 단위로 인덱스가 생성됨
  - 파티션별로 서로 다른 인덱스를 생성할 수 있다는 것을 의미하진 않음

- 예시

  ```sql
  SELECT *
  FROM tb_article
  WHERE reg_userid BETWEEN 'brew' AND 'toto'
    AND reg_date BETWEEN '2009-01-01' AND '2010-12-31'
  ORDER BY reg_userid;
  ```

  ```tex
  | id | table      | partitions  | type  | key          | Extra                    |
  |----+------------+-------------+-------+--------------+--------------------------|
  |  1 | tb_article | p2009,p2010 | range | ix_reguserid | Using where; Using index |
  ```

  - 별도 정렬 작업을 의미하는 'Using filesort' 미표시
    - 2009, 2010 파티션에서 일치 레코드 가져온 후 파티션 결과를 병합하여 reg_userid 컬럼 값으로 다시 정렬해야 할 것처럼 보이지만 아님
    - 여러 파티션에 대해 인덱스 스캔 수행 시 각 파티션으로부터 조건에 일치하는 레코드를 정렬된 순서대로 읽으면서 우선순위 큐(Priority Queue)에 임시로 저장
    - 우선순위 큐에서 필요한 순서(인덱스의 정렬 순서)대로 데이터를 가져가는 것
    - 이는 각 파티션에서 읽은 데이터가 이미 정렬되어 있는 상태라서 가능한 방법

<br>

<img src="./images/13-6.png" alt="drawing" width="80%" align="left" />

<br>

##### 파티션 프루닝(partion pruning)

- 위 그림 13.6처럼 옵티마이저에 의해 3개의 파티션 가운데 2개만 읽어도 된다고 판단되면 불필요한 파티션에 전혀 접근하지 않음
- 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것은 실행 계획에서 배제하는 것을 파티션 프루닝이라 함
- 실행계획 partitions 컬럼에 어떤 파티션만 사용했는지 표시됨

<br>

## 13.2 주의사항

##### 파티션의 제약사항

- 용어

  ```sql
  CREATE TABLE tb_article (
    article_id INT NOT NULL,
    reg_date DATETIME NOT NULL,
    ...
    PRIMARY KEY(article_id, reg_date)
  ) PARTITION BY RANGE ( YEAR(reg_date) ) (
      PARTITION p2009 VALUES LESS THAN (2010),
      PARTITION p2010 VALUES LESS THAN (2011),
      PARTITION p2011 VALUES LESS THAN (2012),
      PARTITION p9999 VALUES LESS THAN MAXVALUE,
  );
  ```

  - `PARTITION BY RANGE` 레인지 파티션 사용
  - `reg_date` reg_date가 파티션 컬럼
  - `YEAR(reg_date)` 파티션 표현식
  - 즉 tb_article 테이블은 reg_date 컬럼에서 YEAR() 내장 함수를 이용해 연도만 추출하고, 그 연도를 이용해 테이블을 연도 범위별로 파티션하고 있음

- 제약사항

  - 스토어드 루틴, UDF, 사용자 변수 등을 파티션 표현식에 사용할 수 없음

  - 파티션 표현식은 일반적으로 컬럼 그 자체 또는 MySQL 내장 함수 사용

    (일부 함수는 파티션 생성은 가능하지만 파티션 프루닝 지원하지 않을 수도 있음)

  - PK 포함 unique index는 파티션 키 컬럼을 포함해야 함
  - 인덱스는 모두 로컬 인덱스이며, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있음. 파티션 개별로 인덱스를 변경하거나 추가할 수 없음
  - 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 가질 수 있음
  - 최대(서브 파티션까지 포함해서) 8192개의 파티션을 가질 수 있음
  - 파티션 생성 이후 MySQL 서버의 sql_mode 시스템 변수 변경은 데이터 파티션의 일관성을 깨뜨릴 수 있음
  - 외래키 사용 불가
  - 전문 검색 인덱스 생성 불가, 전문 검색 쿼리 사용 불가
  - 공간 데이터 저장하는 컬럼 타입(POINT, GEOMETRY, ...) 사용 불가
  - 임시 테이블은 파티션 기능 사용 불가

- 주요 제약사항

  - 모든 unique index에 파티션 키 컬럼이 포함되어야 함
    - 위 예시에서 article_id가 auto_increment라 단일 pk로 사용해도 되지만, reg_date 파티션 키 컬럼이 pk의 일부로 들어가야 한다는 제약사항 때문에 (article_id, reg_date) PK 선정
  - 기본 산술 연산자(+, -, *), 내장 함수 사용 가능
    - 사용 가능한 내장 함수는 [매뉴얼](https://dev.mysql.com/doc/refman/8.0/en/partitioning-limitations-functions.html) 참조

<br>

##### 파티션 사용 시 주의사항

- 파티션과 유니크 키(PK 포함)

  - 종류와 관계없이 테이블에 유니크 인덱스(프라이머리 키 포함)가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 컬럼을 포함해야 함

  - 유니크 키에 대해 파티션 키가 제대로 설정되었는지 확인하려면 각 유니크 키에 대해 값이 주어졌을 때 해당 레코드가 어느 파티션에 저장되어 있는지 계산할 수 있어야 한다는 점을 기억하자

  - 예시(파티션 생성 불가)

    ```sql
    CREATE TABLE tb_partiton (
      fd1 INT NOT NULL,
      fd2 INT NOT NULL,
      fd3 INT NOT NULL,
      UNIQUE KEY (fd1, fd2)
    ) PARTITION BY HASH (fd3)
      PARTITIONS 4;
    ```

    - 유니크 키와 파티션 키가 전혀 연관이 없어서 불가능

    ```sql
    CREATE TABLE tb_partiton (
      fd1 INT NOT NULL,
      fd2 INT NOT NULL,
      fd3 INT NOT NULL,
      UNIQUE KEY (fd1),
      UNIQUE KEY (fd2)
    ) PARTITION BY HASH (fd1 + fd2)
      PARTITIONS 4;
    ```

    - 첫번째 유니크 키 컬럼인 fd1만으로 파티션 결졍이 되지 않음
    - fd1, fd2 컬럼값 모두 있어야 파티션의 위치를 판단할 수 있음

    ```sql
    CREATE TABLE tb_partiton (
      fd1 INT NOT NULL,
      fd2 INT NOT NULL,
      fd3 INT NOT NULL,
      PRIMARY KEY (fd1),
      UNIQUE KEY (fd2, fd3)
    ) PARTITION BY HASH (fd1 + fd2)
      PARTITIONS 4;
    ```

    - PK 컬럼인 fd1 값만으로 파티션 판단이 되지 않음
    - 유니크 키 fd2, fd3 로도 파티션 위치 결정할 수 없음

  - 예시(파티션 생성 가능)

    ```sql
    CREATE TABLE tb_partiton (
      fd1 INT NOT NULL,
      fd2 INT NOT NULL,
      fd3 INT NOT NULL,
      UNIQUE KEY (fd1, fd2, fd3)
    ) PARTITION BY HASH (fd1)
      PARTITIONS 4;
      
    CREATE TABLE tb_partiton (
      fd1 INT NOT NULL,
      fd2 INT NOT NULL,
      fd3 INT NOT NULL,
      UNIQUE KEY (fd1, fd2)
    ) PARTITION BY HASH (fd1 + fd2)
      PARTITIONS 4;
    
    CREATE TABLE tb_partiton (
      fd1 INT NOT NULL,
      fd2 INT NOT NULL,
      fd3 INT NOT NULL,
      UNIQUE KEY (fd1, fd2, fd3),
      UNIQUE KEY (fd3)
    ) PARTITION BY HASH (fd3)
      PARTITIONS 4;
    ```

- open_files_limit 시스템 변수 설정

  - MySQL에서 일반적으로 테이블을 파일 단위로 관리하므로 동시 오픈된 파일 갯수가 상당히 많아질 수 있음

  - 이를 제한하기 위해 `open_files_limit` 시스템 변수 사용

  - open_files 갯수

    - 파티션되지 않은 테이블은 테이블 1개당 2~3개 수준

    - 파티션 테이블 = 파티션의 갯수 * (2~3개)

  - 쿼리가 적절히 파티션 프루닝으로 최적화되어 일부 파티션만 접근해도 된다고 하더라도 일단 동시에 모든 파티션의 데이터 파일을 오픈해야 함

  - 파티션을 많이 사용하는 경우에는 해당 시스템 변수를 적절히 높은 값으로 다시 설정해야 함

<br>