13. 1 개요

- 13.1.1 파티션을 사용하는 이유

  - 13.1.1 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

    - 인덱스가 커지면 커질수록, SELECT 및 INSERT, UPDATE, DELETE 작업도 함께 느려짐
    - 인덱스 크기가 MySQL이 사용 가능한 메모리 공간보다 크면 쿼리 처리 매우 느려짐
    - 파티션 하지 않고 하나의 큰 테이블로 사용할 경우 인덱스 커짐 + 필요한 물리적 메모리공간 커짐
    - 파티션사용 시 데이터와 인덱스 조각조각 해서 물리적 메모리를 효율적으로 사용할 수 있음
    - 워킹셋 : 전체 데이터 중 활발하게 사용되는 테이블 데이터

  - 13.1.2 데이터의 물리적인 저장소를 분리

    - 데이터, 인덱스 파일이 큰 경우 백업이나 관리 작업 어려워짐

    - 파티션 사용시 파일 크기 조절, 데이터 저장 위치, 디스크 구분한 지정 가능

      → MySQL에서는 테이블 파티션 단위 인덱스 생성, 파티션별 다른 인덱스 생성 지원하지 않음

  - 13.1.1.3 이력 데이터의 효율적인 관리

    - 로그 데이터는 시간이 지나면 별도로 아카이빙하거나 백업 후 삭제 → 불필요 데이터 백업, 삭제 작업 부하 높음
    - 로그 테이블을 파티션 테이블로 관리 하면 불필요 데이터 삭제 작업은 파티션 추가 삭제 작업으로 가능해짐

- 13.1.2 MySQL 파티션의 내부 처리

  - 13.1.2.1 파티션 테이블의 레코드 INSERT

    - INSERT 쿼리 실행 시 파티션키로 파티션 표현식을 평가 → 레코드 저장될 파티션 결정 
    - 파티션 결정 후에는 기존 insert 와 동일하게 파티션 내부에서 처리

  - 13.1.2.2 파티션 테이블의 UPDATE

    - WHERE 조건에 파티션 키 칼럼이 조건으로 존재 할 경우 대상 파티션에서 빠르게 레코드 검색 가능 

      → 조건에 명시되지 않으면 MySQL 서버는 변경 대상 레코드 찾기 위해 테이블의 모든 파티션 검색이 필요함

    - 레코드 변경 과정

      ① 파티션 키 이외 칼럼만 변경 되는 경우 : 일반 테이블 처럼 값만 변경

      ② 파티션 키 칼럼 변경시 : 기존에 저장된 파티션에서 해당 레코드 삭제 + (변경되는 파티션 키 칼럼의 표현식 평가후 새 파티션 결정 및 저장) 

  - 13.1.2.3 파티션 테이블의 검색

    - 파티션 테이블 검색 시 성능에 영향 주는 것  

      - WHERE 절 조건으로 파티션 이용가능 한지 
      - WHERE 절 조건으로 인덱스(인덱스 레인지 스캔) 사용 가능한지

    - 

      | 파티션, 인덱스 상황                         | 실행 방법                                                    |
      | ------------------------------------------- | ------------------------------------------------------------ |
      | 파티션 선택 가능 + 인덱스 효율적 사용가능   | 파티션 개수와 관계 없이 <br />검색을 위해 꼭 필요한 파티션 안의 인덱스만 레인지 스캔 |
      | 파티션 선택 불가 + 인덱스 효율적 사용가능   | 모든 파티션 대상으로 인덱스 레인지 스캔을 수행               |
      | 파티션 선택 가능 + 인덱스 효율적 사용불가   | 검색을 위해 필요한 파티션 내부에서 풀 테이블 스캔            |
      | 파티션 선택 불가능 + 인덱스 효율적 사용불가 | 모든 파티션 검색 + 풀 테이블 스캔 수행                       |

      

  - 10.1.2.4 파티션 테이블의 인덱스 스캔과 정렬

    - MySQL의 파티션 테이블 : 전부 로컬 인덱스 → 파티션과 관계없는 테이블 전체단위의 글로벌 인덱스는 지원하지 않음

    - 파티션 되지 않은 테이블에서는 인덱스를 순서대로 읽으면 그 칼럼으로 정렬된 결과 바로 얻을 수 있음

       →  파티션된 테이블에서는 바로 정렬 안됨

    - 여러 파티션에 대해 인덱스 스캔 수행시 

      ① 각 파티션으로부터 조건에 일치 하는 레코드를 정렬 순서대로 읽음

      ② 결과를 우선순위 큐 (Priority Queue)에 임시로 저장

      ③ 큐에서 다시 필요한 순서(인덱스 정렬순서)대로 데이터 가져감

    - 결국 MySQL 서버가 별도 정렬 작업 수행은 안하지만 내부적인 큐 처리가 필요

  - 10.1.2.5 파티션 프루닝

    - 파티션 프루닝 : 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것 

- 13.2 주의사항

- 13.2.1 파티션의 제약사항

  - 가장 큰 제약사항 : 모든 유니크 인덱스에 파티션 키 칼럼이 포함돼야 한다.

- 13.2.2 파티션 사용시 주의사항

  - 13.2.2.1 파티션과 유니크 키(프라이머리 키 포함)

    - 테이블에 유니크 인데스(PK 포함)가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 칼럼을 포함해야 한다.

  - 13.2.2.2 파티션과 open_files_limit 시스템 변수 설정

    - MySQL에서 일반적으로 테이블을 파일 단위로 관리하므로 서버에 동시에 오픈된 파일 개수 많아질 수 있음

      - ex) 일반 테이블은 1개당 오픈 파일수 2~3개 vs 파티션 테이블은 (파티션 개수 * 2~3개 )

    - 쿼리가 파티션 프루닝 사용해 일부 파티션만 사용해도 동시에 모든 파티션의 데이터 파일 오픈 하게 됨

      → 파티션을 많이 사용하는 경우 opn_files_limit 시스템 변수를 적절히 다시 설정해줄 필요 있음.
