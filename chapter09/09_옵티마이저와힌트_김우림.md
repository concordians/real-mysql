# 09 옵티마이저와 힌트

* 옵티마이저의 역할 : 쿼리의 결과를 최적, 최소 비용으로 만드는 실행 계획을 수립

## 9.1 개요

### 9.1.1 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 순준으로 분리 - SQL 파싱, SQL파서 가 처리
2. SQL 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택 - 최적화 및 실행 계획 수립, 옵티마이저가 처리
3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

### 9.1.2 옵티마이저의 종류

* 비용 기반 최적화
  * 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하)정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출
* 규칙 기반 최적화 
  * 통계 정보를 조사하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립
  * 같은 쿼리에 대해 거의 같은 실행 계획 수립

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

* 옵티마이저가 풀 테이블 스캔 선택하는 경우
  * 테이블 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔 하는 편이 더 빠른 경우 
  * WHERE 절이나 ON절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  * 인덱스 레인지 스캔을 사용할 수 있 는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
* 리드 어헤드 
  * 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에 읽어 **InnoDB 버퍼 풀**에 가져다두는 것
  * 테이블 풀 스캔이 시작되면 처음에는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.
  * 풀 테이블 스캔, 풀 인덱스 스캔에서 사용

### 9.2.2 병렬 처리

* 하나의 쿼리를 여러 스레드가 나누어 동시에 처리하는것을 의미

### 9.2.3 ORDER BY 처리(Using Filesort)

* 정렬을 처리하는 방법
  * 인덱스를 이용하는 방법
  * filesort라는 별도의 처리 이용하는 방법

#### 9.2.3.1 소트 버퍼

* MySQL 이 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용
* 최대 사용 가능한 소트 버퍼의 공간 정해져있음
* 만약 정렬해야 할 레코드 건수가 소트 버퍼로 할당된 공간보다 크다면?
  * 레코드를 여러 조각으로 나눠서 처리, 이 과정에서 임시 저장을 위해 디스크 사용
  * 멀티 머지
  * 디스크 읽기, 쓰기 유발
* 소트 버퍼는 글로벌 메모리 영역, 세션(로컬) 메모리 영역 중 세션 메모리 영역에 해당
* 커넥션이 많을수록, 정렬 작업 많을수록 소트 버퍼로 소비되는 메모리 공간 커짐

#### 9.2.3.2 정렬 알고리즘

* 싱글 패스 : 소트 버퍼에 정렬 기준 칼럼을 포함해  select 대상이 되는 칼럼 전부를 담아서 정렬 수행하는 방식
  * 더 많은 소트 버퍼 공간 필요
* 투 패스 : 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬 수행하고 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select 할 칼럼 가져오는 방식
  * 두 번 읽어야 함
* 싱글 패스 정렬 방식 사용하지 못하는 경우
  * 레코드의 크기가 max_length_for_sort_data시스템 변수에 설정된 값보다 클 때
  * BLOB이나  TEXT타입의 칼럼이 SELECT 대상에 포함될 때

#### 9.2.3.3 정렬 처리방법

| 정렬 저리 방법                                      | 실행 계획의 Extra 칼럼 내용                       |
| --------------------------------------------------- | ------------------------------------------------- |
| **인덱스를 사용한 정렬**                            | 별도 표기 없음                                    |
| **조인에서 드라이빙 테이블만 정렬**                 | "Using filesort" 메시지 표시됨                    |
| **조인에서 조인 결과를 임시 테이블로 저장 후 정렬** | "Using temporary; Using filesort" 메시지가 표시됨 |

* Filesort 방식에서 정렬 대상 레코드를 최소화 하기 위해 다음 2가지 방법 중 하나 선택
  * 조인의 드라이빙 테이블만 정렬한 다음 조인 수행
  * 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 수행

##### 9.2.3.3.1 인덱스를 이용한 정렬

* 인덱스를 이용한 정렬을 위해서는
  * **ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속해야 한다.**
  * **ORDER BY 의 순서대로 생성된 인덱스가 있어야 한다.**
  * **WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.**
  * **B-Tree 계열 인덱스여야 한다.**
  * **네스티드 루프 방식의 조인이어야 한다.**
* 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.
* 인덱스를 사용한 정렬이 가능한 이유는 B-Tree인덱스가 **키 값으로 정렬**돼 있기 때문이다.
* 또한 조인이 **네스티드 루프** 방식으로 실행되기 때문에 조인 떄문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.

##### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬

* 이 방법으로 정렬이 처리되려면
  * 드라이빙 테이블의 칼럼만으로 ORDER BY를 작성해야 한다.

##### 9.2.3.3.3 임시 테이블을 이용한 정렬

* 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요
  * 조인의 드라이빙 테이블만 정렬할 수 없는 경우
  * (정렬 기준 칼럼이 드라이빙 테이블이 아니라 드리븐 테이블에 있는 칼럼)
* "Using temporary;Using filesort"
  * 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미

##### 9.2.3.3.4 정렬 처리 방법의 성능 비교

* 일반적으로 LIMIT은 테이블이나 처리 결과의 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량을 줄이는 역할

* 하지만 ORDER BY나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT건수만큼만 가져와서 처리하는게 불가능

  ###### 9.2.3.3.4.1 스트리밍 방식

  * 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때 마다 바로바로 클라이언트로 전송해주는 방식
  * 스트리밍 방식은 LIMIT처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 줄여줌

  ###### 9.2.3.3.4.2 버퍼링 방식

  * GROUP BY 나 ORDER BY 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다.
  * 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그루핑해서 차례대로 보내야 하기 때문이다.
  * 버퍼링 방식으로 처리되는 쿼리는 LIMIT처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 안됨
  * ORDER BY 의 3가지 처리 방법 가운데 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링 된 후에 정렬된다.

* 어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만든다.
* **가능하다면 인덱스를 사용한 정렬로 유도하고, 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도**하는 것도 좋은 튜닝 방법









## 9.4 쿼리 힌트

* 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려주는 방법
* 쿼리 힌트 종류
  * 인덱스 힌트
  * 옵티마이저 힌트

### 9.4.1 인덱스 힌트

* STRAIGHT_JOIN, USE_INDEX 등, MySQL 서버에 옵티마이저 힌트 도입되기 전 사용되던 기능
* SQL 문접에 맞게 사용해야 하기 때문에 사용하게 되면 ANSI-SQL 표준 문법을 준수하지 못하게 됨
* 인덱스 힌트보다는 옵티마이저 힌트 사용 권장

#### 9.4.1.1 STRAIGTH_JOIN

*  옵티마이저 힌트인 동시에 조인 키워드
* 조인 순서를 고정
* 조인 순서 결정 요소
  * 조인을 하기 위한 칼럼들의 인덱스 여부
  * 레코드가 적은 테이블을 드라이빙으로 선택
* STRAIGHT_JOIN 키워드는 SELECT 키워드 뒤에 사용
* 조인 순서 결정 기준
  * 임시 테이블 & 일반 테이블의 조인 : 일반적으로 임시 테이블을 드라이빙 테이블로 선정
  * 임시 테이블끼리 조인 : 임시 테이블은 인덱스가 없기 때문에 어느 테이블을 드라이빙으로 읽어도 무관하므로 크기가 작은 테이블을 드라이빙으로 선택
  * 일반 테이블끼리 조인 : 양쪽 모두 조인 칼럼에 인덱스가 있거나 양쪽 모두 없으면 레코드 건수 적은 테이블 드라이빙 테이블로, 이외에는 조인 칼럼에 인덱스 없는 테이블을 드라이빙으로
* STRAIGH_JOIN 힌트와 비슷한 역할 하는 옵티마이저 힌트(뒤에서 다룸)
  * JOIN_FIXED_ORDER
  * JOIN_ORDER
  * JOIN_PREFIX
  * JOIN_SUFFIX 

#### 9.4.1.2 USE INDEX / FORCE INDEX / IGNORE INDEX

* 옵티마이저가 사용할 인덱스를 선택할 때, 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러 개 존재하는 경우 선택에 실수를 하는 경우 존재 -> 특정 인덱스 사용하도록 유도
* 종류
  * USE INDEX : 특정 테이블의 인덱스 사용하도록 권장
  * FORCE INDEX : USE INDEX보다 강력
  * IGNORE INDEX : 특정 인덱스 사용 못하도록 하는 용도
* 인덱스 힌트 용도 명시
  * USE INDEX FOR JOIN : JOIN 키워드는 테이블 간 조인 뿐만 아니라 레코드 검색 위한 용도까지 포함하는 용어
  * USE INDEX FOR ORDER BY : 명시된 인덱스를 ORDER BY 용도로만 사용할 수 있게 제한
  * USE INDEX FOR GROUP BY : 명시된 인덱스를 GROUP BY 용도로만 사용할 수 있게 제한
* 인덱스의 사용법, 좋은 실행 계획이 어떤 것인지 판단하기 힘든 상황이라면 힌트를 사용해 옵티마이저의 실행 계획에 강제로 영향을 미치는 것은 피하는게 좋다
  * 최적의 실행 계획은 그때그때 변하기 때문에 옵티마이저가 쿼리가 도는 시점에 통계 정보를 가지고 실행 계획을 선택하게 하는것이 좋다

#### 9.4.1.3 SQL_CALC_FOUND_ROWS 

* LIMIT을 만족하는 수만큼의 레코드를 찾았어도 끝까지 검색을 수행해서 FOUND_ROWS() 함수를 이용해 LIMIT을 제외한 조건을 만족하는 레코드 건수 출력
* 사용하면 안되는 이유
  * LIMIT조건에 지정된 횟수가 아닌 검색 조건에 만족하는 레코드 전부를 읽어봐야 함, 인덱스를 통해 실제 데이터 레코드를 찾아가는 작업을 전체 횟수만큼 실행해야 함, 랜덤 I/O도 그만큼 발생
* 대안

```mysql
mysql> SELECT COUNT(*) FROM employees WHERE first_name='Georgi';
mysql> SELECT * FROM employees WHERE first_name='Goergi' LIMIT 0, 20;
```

* COUNT(*) 쿼리를 사용하면 실제 데이터 레코드를 찾아 가기 위한 랜덤 I/O는 발생하지 않는다. (**커버링 인덱스** 쿼리이기 때문)
* 두번째 쿼리에서 LIMIT 0, 20 제한에 의해 랜덤 I/O는 20번만 발생

### 9.4.2 옵티마이저 힌트

#### 9.4.2.1 옵티마이저 힌트 종류

* 인덱스 
* 테이블
* 쿼리블록
* 글로벌

#### 9.4.2.2 MAX_EXECUTION_TIME

* 쿼리의 최대 실행 시간을 설정하는 힌트
* 지정된 시간 초과하면 쿼리 실패

#### 9.4.2.3 SET_VAR

* MySQL 서버의 시스템 변수를 제어
* 실행 계획 바꾸는 용도 뿐만 아니라 조인 버퍼나 정렬용 버퍼(소트 버퍼)의 크기를 일시적으로 증가지켜 대용량 처리 쿼리의 성능을 향상시키는 용도로도 사용할 수 있다.

#### 9.4.2.4 SEMIJOIN & NO_SEMIJOIN

| 최적화 전략        | 힌트                      |
| ------------------ | ------------------------- |
| DUPLICATE Weed-out | SEMIJOIN(DUPSWEEDOUT)     |
| Firsh Match        | SEMIJOIN(FIRSTMATCH)      |
| Loose Scan         | SEMIJOIN(LOOSESCAN)       |
| Materialization    | SEMIJOIN(MATERIALIZATION) |
| Table Pull-out     | 없음                      |

* 세미 조인 최적화 힌트는 외부 쿼리가 아니라 서브쿼리에 명시해야 한다.
* 다른 방법으로는 우선 서브쿼리에 쿼리 블록 이름을 정의하고 실제 세미조인 힌트는 외부 쿼리 블록에 명시한다.

#### 9.4.2.5 SUBQUERY

* 세미 조인 최적화가 사용되지 못할 때 사용하는 최적화 방법

| 최적화 방법     | 힌트                      |
| --------------- | ------------------------- |
| IN-to-EXISTS    | SUBQUERY(INTOEXISTS)      |
| Materialization | SUBQUERY(MATERIALIZATION) |



#### 9.4.2.6 BNL & NO_BNL & HASHJOIN & NO_HASHJOIN

* 8.0.18 버전부터 도입된 해시 조인 알고리즘이 8.0.20 버전부터 블록 네스티드 루프 조인까지 대체
* BNL 힌트, NO_BNL힌트는 해시 조인을 사용하도록 유도하는 힌트로 용도가 변경

#### 9.4.2.7 JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX

* STRAIGHT_JOIN 힌트는 쿼리의 FORM절에 사용된 테이블의 순서를 조인 순서에 맞게 변경해야 한다는 번거로움
* 이러한 단점 보완하기 위함
  * JOIN_FIXED_ORDER : STRAIGHT_JOIN 힌트와 동일하게 FROM절의 테이블 순서대로 조인을 실행하게 하는 힌트 
  * JOIN_ORDER : FROM절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인을 실행하는 힌트
  * JOIN_PREFIX  : 조인에서 드라이빙 테이블만 강제
  * JOIN_SUFFIX : 조인에서 드리븐 테이블만 강제

#### 9.4.2.8 MERGE & NO_MERGE

