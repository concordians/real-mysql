# 9. 옵티마이저와 힌트

9.1 개요

9.1.1 쿼리 실행 절차

1. SQL 쿼리를 파싱해 SQL 서버가 이해할 수 있는 수준으로 분리 (파스 트리)
2. SQL 파싱 정보로 어떤 인덱스 이용할지 선택
3. 2번에서 선택한 읽기 순서, 인덱스를 이용해 스토리지 엔진 접근해 데이터 획득

9.1.2 옵티마이저 종류

- 규칙 기반 최적화 방법 : 옵티마이저에 내장된 우선순위 따라 실행 
→ 같은 쿼리에 항상 같은 실행 방법
- 비용 기반 최적화 방법 : 가능한 여러 방법 중 각 단위 작업의 비용과 대상 테이블의 예측된 통계 정보 이용해 실행 계획별 비용 산출해 최소 비용 방법으로 실행

9.2 기본 데이터 처리

9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- MYSQL 옵티마이저가 풀테이블 스캔을 선택하는 경우
    1. 테이블의 레코드 건수가 너무 작아서 인덱스 없이 풀 테이블 스캔이 더 빠른 경우
    2. where , on 절에 인덱스 이용할 수 있는 적절한 조건 없는 경우
    3. 인덱스 레인지 스캔을 사용할 수 있어도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- InnoDB 스토리지 엔진 : 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에서 리드 어헤드 작업이 자동 시작
    - 리드 어헤드 : 어떤 영역의 데이터의 필요를 예측해 요청 전 미리 디스크에서 읽어 InnoDB 버퍼풀에 저장
    - 풀 테이블 스캔 실행 → 포그라운드 스레드 에서 몇개 페이지 읽기 실행 → (특정시점부터) 백그라운드 스레드에서 페이지 읽기 실행 → 포그라운드 스레드 에서는 데이터 사용
- MYSQL 서버 내 시스템변수 : innodb_read_ahead_threshold 설정해 수정가능
- 풀 인덱스 스캔에서도 리드 어헤드 사용

```sql
SELECT COUNT(*) FROM employees; // 건수만 조회 하므로 풀 인덱스 스캔

SELECT * FROM employees; // 컬럼 전체 조회 하므로 풀 테이블 스캔
```

9.2.2 병렬 처리
- 병렬 처리 : 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리

```sql
SET SESSION innodb_parallel_read_threads=1;
SELECT COUNT(*) FROM employees;

SET SESSION innodb_parallel_read_threads=2;
SELECT COUNT(*) FROM employees;

// 병렬 처리 스레드 늘수록 처리속도 높아짐
// 서버에 장착된 CPU 코어 개수를 초과하면 오히려 성능 떨어질 수 있음.
```

9.2.3 ORDER BY 처리(Using filesort)

1. 인덱스를 이용하는 방법
    - select 작업 시 이미 인덱스가 정렬돼 있으므로 매우 빠름
    - IDU  작업 시 부가적인 인덱스 추가/삭제 작업이 필요해 느림
2. filesort를 이용하는 방법
    - 인덱스를 생성하지 않아도 되므로 IDU 작업 빠름
    - 레코드 적으면 메모리에서 Filesort 가 처리 되므로 빠름
    - 정렬작업이 쿼리 실행시 처리됨 → 레코드 건수가 많아질수록 쿼리 속도 느려짐
3. 인덱스 이용해 정렬하기 어려운 경우
    - 정렬기준이 너무 많아서 모두 인덱스 생성하기 어려운 경우
    - group by, distinct 결과를 정렬해야 하는 경우
    - union 결과 등 임시 테이블의 결과를 정렬해야 하는 경우
    - 랜덤하게 결과 레코드를 가져와야 하는 경우
